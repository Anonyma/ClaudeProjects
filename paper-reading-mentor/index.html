<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paper Reading Mentor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; }
    .serif { font-family: 'Merriweather', serif; }

    /* PDF Text Layer for selection */
    .textLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      opacity: 0.2;
      line-height: 1.0;
    }
    .textLayer > span {
      color: transparent;
      position: absolute;
      white-space: pre;
      cursor: text;
      transform-origin: 0% 0%;
    }
    .textLayer ::selection {
      background: rgba(59, 130, 246, 0.5);
    }

    /* Highlight overlay */
    .highlight-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #1e293b; }
    ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #64748b; }

    /* Animations */
    @keyframes pulse-border {
      0%, 100% { border-color: rgba(251, 191, 36, 0.5); }
      50% { border-color: rgba(251, 191, 36, 1); }
    }
    .animate-pulse-border { animation: pulse-border 2s ease-in-out infinite; }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fadeIn { animation: fadeIn 0.3s ease-out; }

    /* Mentor chat bubble */
    .mentor-bubble {
      background: linear-gradient(135deg, #1e3a5f 0%, #1e293b 100%);
      border-left: 3px solid #3b82f6;
    }
  </style>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            mentor: '#3b82f6',
            highlight: {
              yellow: 'rgba(251, 191, 36, 0.3)',
              green: 'rgba(34, 197, 94, 0.3)',
              blue: 'rgba(59, 130, 246, 0.3)',
              pink: 'rgba(236, 72, 153, 0.3)',
            }
          }
        }
      }
    }
  </script>
</head>
<body class="dark bg-slate-900 text-slate-100 min-h-screen">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback, useMemo } = React;

    // Configure PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // ============================================
    // CONSTANTS & CONFIGURATION
    // ============================================

    const READING_STEPS = [
      {
        id: 'abstract',
        title: 'Abstract & Title',
        icon: 'üìã',
        description: 'Identify the core problem, approach, and key findings',
        mentorPrompt: `You're helping the reader understand the abstract. Guide them to identify:
1. What problem is being solved?
2. What approach did they take?
3. What are the key findings?
4. Why does this matter?

Keep your response under 100 words. End with 1-2 Socratic questions to check understanding.`,
        lookFor: [
          'The research question or problem statement',
          'The methodology in one sentence',
          'The main finding or contribution',
          'The significance or implications'
        ]
      },
      {
        id: 'figures',
        title: 'Figures & Tables',
        icon: 'üìä',
        description: 'Visual data tells the story - read captions first',
        mentorPrompt: `Guide the reader through examining figures and tables. Teach them to:
1. Read captions FIRST before looking at the figure
2. Identify axes, units, and what's being measured
3. Look for trends, patterns, and outliers
4. Connect visuals to the main claims

Keep under 100 words. Ask questions about what patterns they notice.`,
        lookFor: [
          'Axis labels and units',
          'Caption explanations',
          'Trends and patterns in data',
          'Statistical significance markers'
        ]
      },
      {
        id: 'introduction',
        title: 'Introduction',
        icon: 'üéØ',
        description: 'Understand the gap this research fills',
        mentorPrompt: `Help the reader decode the introduction structure:
1. What's the broader context/field?
2. What has previous work done?
3. What gap or limitation exists?
4. What does this paper aim to do?

Keep under 100 words. Ask about how this connects to the abstract.`,
        lookFor: [
          'Field/domain context',
          'Previous work citations',
          'The "gap" or "however" statement',
          'Thesis or hypothesis'
        ]
      },
      {
        id: 'methods',
        title: 'Methods Overview',
        icon: 'üî¨',
        description: 'Understand the approach, not every detail',
        mentorPrompt: `Guide a high-level methods reading. Focus on:
1. Study design (experimental, observational, etc.)
2. Key variables and how they're measured
3. Sample/dataset characteristics
4. Analysis approach

Don't get lost in specific reagents or parameters. Keep under 100 words.`,
        lookFor: [
          'Study design type',
          'Sample size and selection',
          'Key measurements',
          'Statistical/analysis methods'
        ]
      },
      {
        id: 'results',
        title: 'Results',
        icon: 'üìà',
        description: 'What did they actually find?',
        mentorPrompt: `Help the reader critically examine results:
1. Do results match what figures showed?
2. What's statistically significant vs just mentioned?
3. Are effect sizes meaningful, not just significant?
4. Any unexpected findings?

Keep under 100 words. Ask if results support the claims.`,
        lookFor: [
          'Main findings stated',
          'Statistical significance (p-values)',
          'Effect sizes and confidence intervals',
          'Comparisons to expectations'
        ]
      },
      {
        id: 'discussion',
        title: 'Discussion',
        icon: 'üí≠',
        description: 'How do authors interpret their findings?',
        mentorPrompt: `Guide critical reading of the discussion:
1. How do authors explain their findings?
2. How do they connect to prior work?
3. What limitations do they acknowledge?
4. What limitations do they NOT mention?

Keep under 100 words. Ask about unmentioned limitations.`,
        lookFor: [
          'Interpretation of results',
          'Connections to cited work',
          'Stated limitations',
          'Future directions'
        ]
      },
      {
        id: 'critique',
        title: 'Critical Analysis',
        icon: 'üîç',
        description: 'Your turn to evaluate the paper',
        mentorPrompt: `Now help the reader form their own critical view:
1. Does the evidence support the conclusions?
2. Are there alternative explanations?
3. What questions remain unanswered?
4. Would you cite this paper? Why/why not?

Keep under 100 words. Push them to form an opinion.`,
        lookFor: [
          'Strength of evidence',
          'Alternative explanations',
          'Generalizability',
          'Reproducibility concerns'
        ]
      },
      {
        id: 'synthesis',
        title: 'Synthesis & Notes',
        icon: '‚úçÔ∏è',
        description: 'Consolidate your understanding',
        mentorPrompt: `Help the reader synthesize their learning:
1. What's the one-sentence takeaway?
2. How does this change their understanding?
3. What would they tell a colleague about this paper?
4. What follow-up reading might help?

Encourage them to complete their notes. Keep under 100 words.`,
        lookFor: [
          'Main contribution',
          'Key methodology insight',
          'Limitations to remember',
          'Connections to their work'
        ]
      }
    ];

    const AI_PROVIDERS = {
      ollama: {
        name: 'Ollama (Local)',
        endpoint: 'http://localhost:11434/api/chat',
        model: 'llama3.1:8b-instruct-q4_K_M',
        needsKey: false,
        description: 'Free, runs locally. Install Ollama first.'
      },
      gemini: {
        name: 'Gemini Flash',
        endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent',
        needsKey: true,
        description: 'Fast & cheap (~$0.01/100 papers)'
      },
      claude: {
        name: 'Claude Haiku',
        endpoint: 'https://api.anthropic.com/v1/messages',
        model: 'claude-3-haiku-20240307',
        needsKey: true,
        description: 'Best quality (~$0.05/paper)'
      }
    };

    const MENTOR_SYSTEM_PROMPT = `You are Dr. Reading, a warm but rigorous senior research mentor. Your role is to teach students how to critically read academic papers - not just WHAT to read, but HOW to think about it.

Your style:
- Socratic: Ask probing questions rather than just explaining
- Encouraging but honest: Praise good thinking, gently correct misconceptions
- Practical: Share real-world reading strategies from experienced researchers
- Concise: Keep responses under 150 words

You're guiding a structured reading session. Focus on the current step and help them build good reading habits.`;

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    const generateId = () => Math.random().toString(36).substr(2, 9);

    const formatDate = (date) => new Date(date).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', year: 'numeric'
    });

    // IndexedDB wrapper for PDF storage
    const PaperDB = {
      db: null,

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('PaperReadingMentor', 1);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            resolve();
          };
          request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('papers')) {
              db.createObjectStore('papers', { keyPath: 'id' });
            }
          };
        });
      },

      async savePaper(paper) {
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction('papers', 'readwrite');
          tx.objectStore('papers').put(paper);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      },

      async getPaper(id) {
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction('papers', 'readonly');
          const request = tx.objectStore('papers').get(id);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      },

      async getAllPapers() {
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction('papers', 'readonly');
          const request = tx.objectStore('papers').getAll();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      },

      async deletePaper(id) {
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction('papers', 'readwrite');
          tx.objectStore('papers').delete(id);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      }
    };

    // LocalStorage helpers
    const Storage = {
      get(key, defaultValue = null) {
        try {
          const item = localStorage.getItem(`prm_${key}`);
          return item ? JSON.parse(item) : defaultValue;
        } catch {
          return defaultValue;
        }
      },

      set(key, value) {
        try {
          localStorage.setItem(`prm_${key}`, JSON.stringify(value));
        } catch (e) {
          console.error('Storage error:', e);
        }
      },

      remove(key) {
        localStorage.removeItem(`prm_${key}`);
      }
    };

    // ============================================
    // AI PROVIDER FUNCTIONS
    // ============================================

    async function callAI(provider, apiKey, messages) {
      const config = AI_PROVIDERS[provider];

      try {
        if (provider === 'ollama') {
          const response = await fetch(config.endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: config.model,
              messages: messages.map(m => ({
                role: m.role === 'assistant' ? 'assistant' : m.role === 'system' ? 'system' : 'user',
                content: m.content
              })),
              stream: false
            })
          });

          if (!response.ok) throw new Error('Ollama not running. Start with: ollama run llama3.1:8b-instruct-q4_K_M');
          const data = await response.json();
          return data.message?.content || 'No response from Ollama';
        }

        if (provider === 'gemini') {
          // Convert messages to Gemini format
          const contents = messages
            .filter(m => m.role !== 'system')
            .map(m => ({
              role: m.role === 'assistant' ? 'model' : 'user',
              parts: [{ text: m.content }]
            }));

          const systemInstruction = messages.find(m => m.role === 'system');

          const response = await fetch(`${config.endpoint}?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents,
              systemInstruction: systemInstruction ? { parts: [{ text: systemInstruction.content }] } : undefined,
              generationConfig: {
                maxOutputTokens: 500,
                temperature: 0.7
              }
            })
          });

          if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error?.message || 'Gemini API error');
          }

          const data = await response.json();
          return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response from Gemini';
        }

        if (provider === 'claude') {
          const systemMessage = messages.find(m => m.role === 'system');
          const otherMessages = messages.filter(m => m.role !== 'system');

          const response = await fetch(config.endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': apiKey,
              'anthropic-version': '2023-06-01',
              'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
              model: config.model,
              max_tokens: 500,
              system: systemMessage?.content || MENTOR_SYSTEM_PROMPT,
              messages: otherMessages.map(m => ({
                role: m.role === 'assistant' ? 'assistant' : 'user',
                content: m.content
              }))
            })
          });

          if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error?.message || 'Claude API error');
          }

          const data = await response.json();
          return data.content?.[0]?.text || 'No response from Claude';
        }
      } catch (error) {
        console.error('AI Error:', error);
        throw error;
      }
    }

    // ============================================
    // COMPONENTS
    // ============================================

    // Settings Modal
    function SettingsModal({ isOpen, onClose, settings, onSave }) {
      const [localSettings, setLocalSettings] = useState(settings);

      useEffect(() => {
        setLocalSettings(settings);
      }, [settings, isOpen]);

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
          <div className="bg-slate-800 rounded-xl max-w-lg w-full p-6 animate-fadeIn">
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-xl font-semibold">Settings</h2>
              <button onClick={onClose} className="text-slate-400 hover:text-white">‚úï</button>
            </div>

            <div className="space-y-6">
              {/* AI Provider */}
              <div>
                <label className="block text-sm font-medium mb-2">AI Provider</label>
                <div className="space-y-2">
                  {Object.entries(AI_PROVIDERS).map(([key, config]) => (
                    <label key={key} className={`flex items-start p-3 rounded-lg border cursor-pointer transition
                      ${localSettings.provider === key ? 'border-blue-500 bg-blue-500/10' : 'border-slate-600 hover:border-slate-500'}`}>
                      <input
                        type="radio"
                        name="provider"
                        value={key}
                        checked={localSettings.provider === key}
                        onChange={(e) => setLocalSettings({ ...localSettings, provider: e.target.value })}
                        className="mt-1 mr-3"
                      />
                      <div>
                        <div className="font-medium">{config.name}</div>
                        <div className="text-sm text-slate-400">{config.description}</div>
                      </div>
                    </label>
                  ))}
                </div>
              </div>

              {/* API Keys */}
              {localSettings.provider !== 'ollama' && (
                <div>
                  <label className="block text-sm font-medium mb-2">
                    {AI_PROVIDERS[localSettings.provider]?.name} API Key
                  </label>
                  <input
                    type="password"
                    value={localSettings.apiKeys?.[localSettings.provider] || ''}
                    onChange={(e) => setLocalSettings({
                      ...localSettings,
                      apiKeys: { ...localSettings.apiKeys, [localSettings.provider]: e.target.value }
                    })}
                    placeholder="Enter API key..."
                    className="w-full px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500"
                  />
                  <p className="mt-1 text-xs text-slate-400">
                    Keys are stored locally in your browser only.
                  </p>
                </div>
              )}

              {/* Clear Data */}
              <div className="pt-4 border-t border-slate-700">
                <button
                  onClick={() => {
                    if (confirm('Clear all stored data? This cannot be undone.')) {
                      localStorage.clear();
                      indexedDB.deleteDatabase('PaperReadingMentor');
                      window.location.reload();
                    }
                  }}
                  className="text-red-400 hover:text-red-300 text-sm"
                >
                  Clear All Data
                </button>
              </div>
            </div>

            <div className="flex justify-end gap-3 mt-6">
              <button onClick={onClose} className="px-4 py-2 text-slate-400 hover:text-white">
                Cancel
              </button>
              <button
                onClick={() => { onSave(localSettings); onClose(); }}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg font-medium"
              >
                Save Settings
              </button>
            </div>
          </div>
        </div>
      );
    }

    // Import Paper Modal
    function ImportModal({ isOpen, onClose, onImport }) {
      const [mode, setMode] = useState('upload'); // upload, url, arxiv, search
      const [url, setUrl] = useState('');
      const [arxivId, setArxivId] = useState('');
      const [searchQuery, setSearchQuery] = useState('');
      const [searchResults, setSearchResults] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState('');
      const fileInputRef = useRef(null);

      const handleFileUpload = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        setLoading(true);
        try {
          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          // Try to extract title from first page
          const page = await pdf.getPage(1);
          const textContent = await page.getTextContent();
          const firstLine = textContent.items.slice(0, 10).map(i => i.str).join(' ').trim();

          const paper = {
            id: generateId(),
            title: firstLine.substring(0, 100) || file.name.replace('.pdf', ''),
            authors: [],
            pdfBlob: new Blob([arrayBuffer], { type: 'application/pdf' }),
            pageCount: pdf.numPages,
            createdAt: new Date().toISOString(),
            source: 'upload'
          };

          onImport(paper);
          onClose();
        } catch (err) {
          setError('Failed to load PDF: ' + err.message);
        } finally {
          setLoading(false);
        }
      };

      const handleUrlImport = async () => {
        if (!url.trim()) return;
        setLoading(true);
        setError('');

        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error('Failed to fetch PDF');

          const blob = await response.blob();
          const arrayBuffer = await blob.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          const paper = {
            id: generateId(),
            title: url.split('/').pop().replace('.pdf', ''),
            authors: [],
            pdfBlob: blob,
            pageCount: pdf.numPages,
            createdAt: new Date().toISOString(),
            source: 'url',
            sourceUrl: url
          };

          onImport(paper);
          onClose();
        } catch (err) {
          setError('Failed to fetch PDF. Make sure it\'s a direct PDF link with CORS enabled.');
        } finally {
          setLoading(false);
        }
      };

      const handleArxivImport = async () => {
        const cleanId = arxivId.replace('arxiv:', '').replace('https://arxiv.org/abs/', '').replace('https://arxiv.org/pdf/', '').replace('.pdf', '').trim();
        if (!cleanId) return;

        setLoading(true);
        setError('');

        try {
          // Fetch metadata first
          const metaResponse = await fetch(`https://export.arxiv.org/api/query?id_list=${cleanId}`);
          const metaXml = await metaResponse.text();
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(metaXml, 'text/xml');

          const entry = xmlDoc.querySelector('entry');
          const title = entry?.querySelector('title')?.textContent?.trim() || cleanId;
          const authors = Array.from(entry?.querySelectorAll('author name') || []).map(n => n.textContent);

          // Fetch PDF
          const pdfUrl = `https://arxiv.org/pdf/${cleanId}.pdf`;
          const pdfResponse = await fetch(pdfUrl);
          if (!pdfResponse.ok) throw new Error('Failed to fetch arXiv PDF');

          const blob = await pdfResponse.blob();
          const arrayBuffer = await blob.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          const paper = {
            id: generateId(),
            title,
            authors,
            pdfBlob: blob,
            pageCount: pdf.numPages,
            createdAt: new Date().toISOString(),
            source: 'arxiv',
            arxivId: cleanId,
            sourceUrl: `https://arxiv.org/abs/${cleanId}`
          };

          onImport(paper);
          onClose();
        } catch (err) {
          setError('Failed to import from arXiv: ' + err.message);
        } finally {
          setLoading(false);
        }
      };

      const handleSemanticSearch = async () => {
        if (!searchQuery.trim()) return;
        setLoading(true);
        setError('');

        try {
          const response = await fetch(
            `https://api.semanticscholar.org/graph/v1/paper/search?query=${encodeURIComponent(searchQuery)}&limit=10&fields=title,authors,year,abstract,openAccessPdf`
          );

          if (!response.ok) throw new Error('Search failed');
          const data = await response.json();
          setSearchResults(data.data || []);
        } catch (err) {
          setError('Search failed: ' + err.message);
        } finally {
          setLoading(false);
        }
      };

      const importFromSearch = async (result) => {
        if (!result.openAccessPdf?.url) {
          setError('No open access PDF available for this paper');
          return;
        }

        setLoading(true);
        try {
          const response = await fetch(result.openAccessPdf.url);
          if (!response.ok) throw new Error('Failed to fetch PDF');

          const blob = await response.blob();
          const arrayBuffer = await blob.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          const paper = {
            id: generateId(),
            title: result.title,
            authors: result.authors?.map(a => a.name) || [],
            pdfBlob: blob,
            pageCount: pdf.numPages,
            createdAt: new Date().toISOString(),
            source: 'semantic-scholar',
            sourceUrl: result.openAccessPdf.url
          };

          onImport(paper);
          onClose();
        } catch (err) {
          setError('Failed to import: ' + err.message);
        } finally {
          setLoading(false);
        }
      };

      if (!isOpen) return null;

      return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
          <div className="bg-slate-800 rounded-xl max-w-2xl w-full max-h-[80vh] overflow-hidden flex flex-col animate-fadeIn">
            <div className="flex justify-between items-center p-6 border-b border-slate-700">
              <h2 className="text-xl font-semibold">Import Paper</h2>
              <button onClick={onClose} className="text-slate-400 hover:text-white">‚úï</button>
            </div>

            {/* Mode tabs */}
            <div className="flex border-b border-slate-700">
              {[
                { id: 'upload', label: 'üìÅ Upload', desc: 'Local PDF' },
                { id: 'url', label: 'üîó URL', desc: 'Direct link' },
                { id: 'arxiv', label: 'üìö arXiv', desc: 'By ID' },
                { id: 'search', label: 'üîç Search', desc: 'Semantic Scholar' },
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => { setMode(tab.id); setError(''); }}
                  className={`flex-1 py-3 px-4 text-center transition ${
                    mode === tab.id ? 'bg-slate-700 text-white' : 'text-slate-400 hover:bg-slate-700/50'
                  }`}
                >
                  <div className="font-medium">{tab.label}</div>
                  <div className="text-xs text-slate-500">{tab.desc}</div>
                </button>
              ))}
            </div>

            <div className="p-6 overflow-y-auto flex-1">
              {error && (
                <div className="mb-4 p-3 bg-red-500/20 border border-red-500/50 rounded-lg text-red-300 text-sm">
                  {error}
                </div>
              )}

              {mode === 'upload' && (
                <div
                  onClick={() => fileInputRef.current?.click()}
                  className="border-2 border-dashed border-slate-600 rounded-xl p-12 text-center cursor-pointer hover:border-blue-500 hover:bg-blue-500/5 transition"
                >
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept=".pdf"
                    onChange={handleFileUpload}
                    className="hidden"
                  />
                  <div className="text-4xl mb-4">üìÑ</div>
                  <div className="text-lg font-medium mb-2">Drop PDF here or click to browse</div>
                  <div className="text-slate-400 text-sm">Supports PDF files up to 50MB</div>
                </div>
              )}

              {mode === 'url' && (
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium mb-2">PDF URL</label>
                    <input
                      type="url"
                      value={url}
                      onChange={(e) => setUrl(e.target.value)}
                      placeholder="https://example.com/paper.pdf"
                      className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500"
                    />
                    <p className="mt-2 text-xs text-slate-400">
                      Must be a direct PDF link. Some sites block cross-origin requests.
                    </p>
                  </div>
                  <button
                    onClick={handleUrlImport}
                    disabled={loading || !url.trim()}
                    className="w-full py-3 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded-lg font-medium"
                  >
                    {loading ? 'Importing...' : 'Import from URL'}
                  </button>
                </div>
              )}

              {mode === 'arxiv' && (
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium mb-2">arXiv ID or URL</label>
                    <input
                      type="text"
                      value={arxivId}
                      onChange={(e) => setArxivId(e.target.value)}
                      placeholder="2301.07041 or https://arxiv.org/abs/2301.07041"
                      className="w-full px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500"
                    />
                    <p className="mt-2 text-xs text-slate-400">
                      Enter just the ID (e.g., 2301.07041) or the full arXiv URL.
                    </p>
                  </div>
                  <button
                    onClick={handleArxivImport}
                    disabled={loading || !arxivId.trim()}
                    className="w-full py-3 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded-lg font-medium"
                  >
                    {loading ? 'Importing...' : 'Import from arXiv'}
                  </button>
                </div>
              )}

              {mode === 'search' && (
                <div className="space-y-4">
                  <div className="flex gap-2">
                    <input
                      type="text"
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      onKeyDown={(e) => e.key === 'Enter' && handleSemanticSearch()}
                      placeholder="Search papers by title, topic, or author..."
                      className="flex-1 px-4 py-3 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500"
                    />
                    <button
                      onClick={handleSemanticSearch}
                      disabled={loading}
                      className="px-6 py-3 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded-lg font-medium"
                    >
                      {loading ? '...' : 'Search'}
                    </button>
                  </div>

                  {searchResults.length > 0 && (
                    <div className="space-y-2 max-h-80 overflow-y-auto">
                      {searchResults.map((result, i) => (
                        <div
                          key={i}
                          className="p-4 bg-slate-700/50 rounded-lg hover:bg-slate-700 transition"
                        >
                          <div className="font-medium mb-1">{result.title}</div>
                          <div className="text-sm text-slate-400 mb-2">
                            {result.authors?.slice(0, 3).map(a => a.name).join(', ')}
                            {result.authors?.length > 3 && ' et al.'} ‚Ä¢ {result.year}
                          </div>
                          {result.openAccessPdf?.url ? (
                            <button
                              onClick={() => importFromSearch(result)}
                              disabled={loading}
                              className="text-sm text-blue-400 hover:text-blue-300"
                            >
                              üì• Import PDF
                            </button>
                          ) : (
                            <span className="text-sm text-slate-500">No open access PDF</span>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    // PDF Viewer Component
    function PDFViewer({ paper, currentPage, onPageChange, highlights, zoom }) {
      const canvasRef = useRef(null);
      const containerRef = useRef(null);
      const [pdf, setPdf] = useState(null);
      const [rendering, setRendering] = useState(false);
      const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

      // Load PDF
      useEffect(() => {
        if (!paper?.pdfBlob) return;

        const loadPdf = async () => {
          try {
            const arrayBuffer = await paper.pdfBlob.arrayBuffer();
            const loadedPdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            setPdf(loadedPdf);
          } catch (err) {
            console.error('Failed to load PDF:', err);
          }
        };

        loadPdf();
      }, [paper?.id]);

      // Render page
      useEffect(() => {
        if (!pdf || !canvasRef.current || rendering) return;

        const renderPage = async () => {
          setRendering(true);
          try {
            const page = await pdf.getPage(currentPage);
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');

            const viewport = page.getViewport({ scale: zoom });
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            setDimensions({ width: viewport.width, height: viewport.height });

            await page.render({
              canvasContext: ctx,
              viewport
            }).promise;
          } catch (err) {
            console.error('Failed to render page:', err);
          } finally {
            setRendering(false);
          }
        };

        renderPage();
      }, [pdf, currentPage, zoom]);

      const pageHighlights = highlights.filter(h => h.page === currentPage);

      return (
        <div ref={containerRef} className="relative bg-slate-950 rounded-lg overflow-auto h-full">
          {!paper ? (
            <div className="flex items-center justify-center h-full text-slate-400">
              <div className="text-center">
                <div className="text-6xl mb-4">üìÑ</div>
                <div className="text-lg">No paper loaded</div>
                <div className="text-sm">Import a paper to begin</div>
              </div>
            </div>
          ) : (
            <div className="relative inline-block min-w-full">
              <canvas ref={canvasRef} className="block mx-auto" />

              {/* Highlight overlay */}
              <svg
                className="highlight-layer"
                style={{ width: dimensions.width, height: dimensions.height }}
                viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
              >
                {pageHighlights.map((h, i) => (
                  <rect
                    key={i}
                    x={h.bbox.x * zoom}
                    y={h.bbox.y * zoom}
                    width={h.bbox.width * zoom}
                    height={h.bbox.height * zoom}
                    fill={h.color || '#FBBF24'}
                    fillOpacity={0.3}
                    stroke={h.color || '#FBBF24'}
                    strokeWidth={2}
                    strokeOpacity={0.6}
                    rx={4}
                  />
                ))}
              </svg>
            </div>
          )}

          {rendering && (
            <div className="absolute inset-0 flex items-center justify-center bg-slate-900/50">
              <div className="animate-spin text-2xl">‚è≥</div>
            </div>
          )}
        </div>
      );
    }

    // Reading Guide Panel
    function ReadingGuide({ currentStep, onStepChange, messages, onSendMessage, loading, stepProgress }) {
      const [input, setInput] = useState('');
      const messagesEndRef = useRef(null);
      const step = READING_STEPS[currentStep];

      useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, [messages]);

      const handleSend = () => {
        if (!input.trim() || loading) return;
        onSendMessage(input.trim());
        setInput('');
      };

      return (
        <div className="flex flex-col h-full">
          {/* Step header */}
          <div className="p-4 border-b border-slate-700">
            <div className="flex items-center gap-2 mb-2">
              <span className="text-2xl">{step.icon}</span>
              <h2 className="text-lg font-semibold">{step.title}</h2>
              <span className="ml-auto text-sm text-slate-400">
                Step {currentStep + 1}/{READING_STEPS.length}
              </span>
            </div>
            <p className="text-sm text-slate-400">{step.description}</p>
          </div>

          {/* What to look for */}
          <div className="p-4 bg-slate-800/50 border-b border-slate-700">
            <div className="text-xs font-medium text-slate-400 mb-2">üìö What to look for:</div>
            <ul className="text-sm space-y-1">
              {step.lookFor.map((item, i) => (
                <li key={i} className="flex items-start gap-2">
                  <span className="text-slate-500">‚Ä¢</span>
                  <span className="text-slate-300">{item}</span>
                </li>
              ))}
            </ul>
          </div>

          {/* Messages */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.map((msg, i) => (
              <div
                key={i}
                className={`animate-fadeIn ${
                  msg.role === 'assistant'
                    ? 'mentor-bubble p-4 rounded-lg'
                    : 'bg-slate-700 p-3 rounded-lg ml-8'
                }`}
              >
                {msg.role === 'assistant' && (
                  <div className="flex items-center gap-2 mb-2 text-xs text-blue-400">
                    <span>üéì</span>
                    <span className="font-medium">Dr. Reading</span>
                  </div>
                )}
                <div className="text-sm whitespace-pre-wrap">{msg.content}</div>
              </div>
            ))}
            {loading && (
              <div className="mentor-bubble p-4 rounded-lg animate-pulse">
                <div className="flex items-center gap-2 text-xs text-blue-400">
                  <span>üéì</span>
                  <span>Thinking...</span>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* Input */}
          <div className="p-4 border-t border-slate-700">
            <div className="flex gap-2 mb-3">
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && handleSend()}
                placeholder="Ask a question..."
                className="flex-1 px-4 py-2 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm"
              />
              <button
                onClick={handleSend}
                disabled={loading || !input.trim()}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 rounded-lg text-sm font-medium"
              >
                Send
              </button>
            </div>

            {/* Navigation */}
            <div className="flex justify-between">
              <button
                onClick={() => onStepChange(currentStep - 1)}
                disabled={currentStep === 0}
                className="flex items-center gap-1 px-3 py-1.5 text-sm text-slate-400 hover:text-white disabled:opacity-30"
              >
                ‚Üê Back
              </button>
              <button
                onClick={() => onStepChange(currentStep + 1)}
                disabled={currentStep === READING_STEPS.length - 1}
                className="flex items-center gap-1 px-4 py-1.5 text-sm bg-slate-700 hover:bg-slate-600 rounded-lg disabled:opacity-30"
              >
                Next Step ‚Üí
              </button>
            </div>
          </div>
        </div>
      );
    }

    // Notes Panel
    function NotesPanel({ notes, onUpdateNotes, currentStep }) {
      const step = READING_STEPS[currentStep];

      const stepNotes = notes[currentStep] || { keyPoints: '', questions: '', summary: '' };

      const updateNote = (field, value) => {
        onUpdateNotes(currentStep, { ...stepNotes, [field]: value });
      };

      const exportNotes = () => {
        let markdown = `# Reading Notes\n\n`;

        READING_STEPS.forEach((s, i) => {
          const n = notes[i];
          if (!n) return;

          markdown += `## ${s.icon} ${s.title}\n\n`;

          if (n.keyPoints?.trim()) {
            markdown += `### Key Points\n${n.keyPoints}\n\n`;
          }
          if (n.questions?.trim()) {
            markdown += `### Questions\n${n.questions}\n\n`;
          }
          if (n.summary?.trim()) {
            markdown += `### Summary\n${n.summary}\n\n`;
          }
        });

        const blob = new Blob([markdown], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'reading-notes.md';
        a.click();
        URL.revokeObjectURL(url);
      };

      return (
        <div className="flex flex-col h-full">
          <div className="p-4 border-b border-slate-700 flex items-center justify-between">
            <h2 className="font-semibold">Your Notes</h2>
            <button
              onClick={exportNotes}
              className="text-sm text-blue-400 hover:text-blue-300"
            >
              üì• Export
            </button>
          </div>

          <div className="p-4 border-b border-slate-700">
            <div className="text-xs font-medium text-slate-400 mb-1">Current Step</div>
            <div className="flex items-center gap-2">
              <span>{step.icon}</span>
              <span className="font-medium">{step.title}</span>
            </div>
          </div>

          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2 text-slate-300">
                üìå Key Points
              </label>
              <textarea
                value={stepNotes.keyPoints}
                onChange={(e) => updateNote('keyPoints', e.target.value)}
                placeholder="‚Ä¢ Main findings...&#10;‚Ä¢ Important methods...&#10;‚Ä¢ Key statistics..."
                className="w-full h-28 px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm resize-none"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-2 text-slate-300">
                ‚ùì Questions
              </label>
              <textarea
                value={stepNotes.questions}
                onChange={(e) => updateNote('questions', e.target.value)}
                placeholder="? Why did they...&#10;? What about...&#10;? How does this relate to..."
                className="w-full h-28 px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm resize-none"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-2 text-slate-300">
                üìù Summary
              </label>
              <textarea
                value={stepNotes.summary}
                onChange={(e) => updateNote('summary', e.target.value)}
                placeholder="In one sentence, this section shows that..."
                className="w-full h-24 px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-blue-500 text-sm resize-none"
              />
            </div>
          </div>
        </div>
      );
    }

    // Paper Library
    function PaperLibrary({ papers, onSelectPaper, onDeletePaper, onImport, selectedPaperId }) {
      return (
        <div className="flex flex-col h-full">
          <div className="p-4 border-b border-slate-700 flex items-center justify-between">
            <h2 className="font-semibold">üìö Paper Library</h2>
            <button
              onClick={onImport}
              className="px-3 py-1.5 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm font-medium"
            >
              + Import
            </button>
          </div>

          <div className="flex-1 overflow-y-auto p-2">
            {papers.length === 0 ? (
              <div className="text-center py-8 text-slate-400">
                <div className="text-4xl mb-2">üì≠</div>
                <div className="text-sm">No papers yet</div>
                <div className="text-xs">Import your first paper to begin</div>
              </div>
            ) : (
              <div className="space-y-2">
                {papers.map(paper => (
                  <div
                    key={paper.id}
                    onClick={() => onSelectPaper(paper)}
                    className={`p-3 rounded-lg cursor-pointer transition ${
                      selectedPaperId === paper.id
                        ? 'bg-blue-600/20 border border-blue-500/50'
                        : 'bg-slate-700/50 hover:bg-slate-700 border border-transparent'
                    }`}
                  >
                    <div className="font-medium text-sm mb-1 line-clamp-2">{paper.title}</div>
                    <div className="flex items-center justify-between text-xs text-slate-400">
                      <span>{paper.pageCount} pages</span>
                      <div className="flex items-center gap-2">
                        <span>{formatDate(paper.createdAt)}</span>
                        <button
                          onClick={(e) => { e.stopPropagation(); onDeletePaper(paper.id); }}
                          className="text-red-400 hover:text-red-300"
                        >
                          üóëÔ∏è
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    }

    // Main App
    function App() {
      // State
      const [view, setView] = useState('library'); // library, reading
      const [papers, setPapers] = useState([]);
      const [selectedPaper, setSelectedPaper] = useState(null);
      const [currentPage, setCurrentPage] = useState(1);
      const [currentStep, setCurrentStep] = useState(0);
      const [zoom, setZoom] = useState(1.2);
      const [messages, setMessages] = useState({});
      const [notes, setNotes] = useState({});
      const [highlights, setHighlights] = useState([]);
      const [aiLoading, setAiLoading] = useState(false);
      const [settings, setSettings] = useState({
        provider: 'ollama',
        apiKeys: {}
      });
      const [showSettings, setShowSettings] = useState(false);
      const [showImport, setShowImport] = useState(false);
      const [dbReady, setDbReady] = useState(false);

      // Initialize
      useEffect(() => {
        const init = async () => {
          await PaperDB.init();
          setDbReady(true);

          const savedPapers = await PaperDB.getAllPapers();
          setPapers(savedPapers);

          const savedSettings = Storage.get('settings', { provider: 'ollama', apiKeys: {} });
          setSettings(savedSettings);

          const savedNotes = Storage.get('notes', {});
          setNotes(savedNotes);
        };

        init();
      }, []);

      // Save settings
      useEffect(() => {
        if (dbReady) {
          Storage.set('settings', settings);
        }
      }, [settings, dbReady]);

      // Save notes
      useEffect(() => {
        if (dbReady && Object.keys(notes).length > 0) {
          Storage.set('notes', notes);
        }
      }, [notes, dbReady]);

      // Handle paper import
      const handleImportPaper = async (paper) => {
        await PaperDB.savePaper(paper);
        setPapers(prev => [...prev, paper]);
      };

      // Handle paper selection
      const handleSelectPaper = (paper) => {
        setSelectedPaper(paper);
        setCurrentPage(1);
        setCurrentStep(0);
        setMessages({});
        setView('reading');

        // Load saved session if exists
        const sessionKey = `session_${paper.id}`;
        const savedSession = Storage.get(sessionKey);
        if (savedSession) {
          setCurrentStep(savedSession.currentStep || 0);
          setMessages(savedSession.messages || {});
          setNotes(savedSession.notes || {});
        }
      };

      // Handle paper delete
      const handleDeletePaper = async (id) => {
        if (!confirm('Delete this paper?')) return;
        await PaperDB.deletePaper(id);
        setPapers(prev => prev.filter(p => p.id !== id));
        if (selectedPaper?.id === id) {
          setSelectedPaper(null);
          setView('library');
        }
      };

      // Handle step change
      const handleStepChange = (newStep) => {
        if (newStep < 0 || newStep >= READING_STEPS.length) return;
        setCurrentStep(newStep);

        // Initialize messages for new step if needed
        if (!messages[newStep]) {
          // Send initial mentor message
          sendMentorMessage(newStep, null, true);
        }
      };

      // Send message to AI mentor
      const sendMentorMessage = async (stepIndex, userMessage = null, isInitial = false) => {
        const step = READING_STEPS[stepIndex];
        const stepMessages = messages[stepIndex] || [];

        // Build conversation
        const conversationMessages = [
          { role: 'system', content: MENTOR_SYSTEM_PROMPT },
          { role: 'user', content: `Current step: ${step.title}\n\nContext: ${step.mentorPrompt}` }
        ];

        if (!isInitial) {
          // Add previous messages
          stepMessages.forEach(msg => {
            conversationMessages.push({ role: msg.role, content: msg.content });
          });

          // Add new user message
          if (userMessage) {
            conversationMessages.push({ role: 'user', content: userMessage });
            setMessages(prev => ({
              ...prev,
              [stepIndex]: [...(prev[stepIndex] || []), { role: 'user', content: userMessage }]
            }));
          }
        }

        setAiLoading(true);

        try {
          const apiKey = settings.apiKeys?.[settings.provider];
          if (AI_PROVIDERS[settings.provider].needsKey && !apiKey) {
            throw new Error(`Please configure your ${AI_PROVIDERS[settings.provider].name} API key in settings.`);
          }

          const response = await callAI(settings.provider, apiKey, conversationMessages);

          setMessages(prev => ({
            ...prev,
            [stepIndex]: [...(prev[stepIndex] || []), { role: 'assistant', content: response }]
          }));
        } catch (error) {
          setMessages(prev => ({
            ...prev,
            [stepIndex]: [...(prev[stepIndex] || []), {
              role: 'assistant',
              content: `‚ö†Ô∏è ${error.message}\n\nTip: Check your settings or try Ollama for free local AI.`
            }]
          }));
        } finally {
          setAiLoading(false);
        }
      };

      // Handle send message
      const handleSendMessage = (message) => {
        sendMentorMessage(currentStep, message, false);
      };

      // Update notes
      const handleUpdateNotes = (stepIndex, stepNotes) => {
        setNotes(prev => ({
          ...prev,
          [stepIndex]: stepNotes
        }));
      };

      // Save session
      useEffect(() => {
        if (selectedPaper && dbReady) {
          const sessionKey = `session_${selectedPaper.id}`;
          Storage.set(sessionKey, {
            currentStep,
            messages,
            notes
          });
        }
      }, [selectedPaper, currentStep, messages, notes, dbReady]);

      // Calculate progress
      const progress = useMemo(() => {
        const completedSteps = Object.keys(messages).length;
        return Math.round((completedSteps / READING_STEPS.length) * 100);
      }, [messages]);

      if (!dbReady) {
        return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-xl">Loading...</div>
          </div>
        );
      }

      return (
        <div className="min-h-screen flex flex-col">
          {/* Header */}
          <header className="bg-slate-800 border-b border-slate-700 px-4 py-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-4">
                <h1 className="text-xl font-bold flex items-center gap-2">
                  <span>üéì</span>
                  <span className="serif">Paper Reading Mentor</span>
                </h1>
                {selectedPaper && view === 'reading' && (
                  <button
                    onClick={() => setView('library')}
                    className="text-sm text-slate-400 hover:text-white"
                  >
                    ‚Üê Library
                  </button>
                )}
              </div>

              {selectedPaper && view === 'reading' && (
                <div className="flex-1 mx-8">
                  <div className="text-sm font-medium truncate max-w-xl mx-auto text-center">
                    {selectedPaper.title}
                  </div>
                  <div className="flex items-center gap-2 justify-center mt-1">
                    <span className="text-xs text-slate-400">
                      Step {currentStep + 1}/{READING_STEPS.length}
                    </span>
                    <div className="w-48 h-1.5 bg-slate-700 rounded-full overflow-hidden">
                      <div
                        className="h-full bg-blue-500 transition-all duration-300"
                        style={{ width: `${progress}%` }}
                      />
                    </div>
                    <span className="text-xs text-slate-400">{progress}%</span>
                  </div>
                </div>
              )}

              <button
                onClick={() => setShowSettings(true)}
                className="p-2 text-slate-400 hover:text-white hover:bg-slate-700 rounded-lg"
              >
                ‚öôÔ∏è
              </button>
            </div>
          </header>

          {/* Main content */}
          <main className="flex-1 overflow-hidden">
            {view === 'library' ? (
              <div className="h-full max-w-3xl mx-auto">
                <PaperLibrary
                  papers={papers}
                  onSelectPaper={handleSelectPaper}
                  onDeletePaper={handleDeletePaper}
                  onImport={() => setShowImport(true)}
                  selectedPaperId={selectedPaper?.id}
                />
              </div>
            ) : (
              <div className="h-full grid grid-cols-[320px_1fr_320px]">
                {/* Left: Reading Guide */}
                <div className="border-r border-slate-700 overflow-hidden">
                  <ReadingGuide
                    currentStep={currentStep}
                    onStepChange={handleStepChange}
                    messages={messages[currentStep] || []}
                    onSendMessage={handleSendMessage}
                    loading={aiLoading}
                    stepProgress={{}}
                  />
                </div>

                {/* Center: PDF Viewer */}
                <div className="flex flex-col overflow-hidden">
                  <div className="flex-1 overflow-hidden p-4">
                    <PDFViewer
                      paper={selectedPaper}
                      currentPage={currentPage}
                      onPageChange={setCurrentPage}
                      highlights={highlights}
                      zoom={zoom}
                    />
                  </div>

                  {/* PDF Controls */}
                  <div className="bg-slate-800 border-t border-slate-700 px-4 py-2 flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                        disabled={currentPage <= 1}
                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 disabled:opacity-30 rounded text-sm"
                      >
                        ‚óÑ Prev
                      </button>
                      <span className="text-sm text-slate-300">
                        Page {currentPage} / {selectedPaper?.pageCount || 1}
                      </span>
                      <button
                        onClick={() => setCurrentPage(p => Math.min(selectedPaper?.pageCount || 1, p + 1))}
                        disabled={currentPage >= (selectedPaper?.pageCount || 1)}
                        className="px-3 py-1 bg-slate-700 hover:bg-slate-600 disabled:opacity-30 rounded text-sm"
                      >
                        Next ‚ñ∫
                      </button>
                    </div>

                    <div className="flex items-center gap-2">
                      <button
                        onClick={() => setZoom(z => Math.max(0.5, z - 0.2))}
                        className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                      >
                        ‚àí
                      </button>
                      <span className="text-sm text-slate-300 w-16 text-center">
                        {Math.round(zoom * 100)}%
                      </span>
                      <button
                        onClick={() => setZoom(z => Math.min(3, z + 0.2))}
                        className="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-sm"
                      >
                        +
                      </button>
                    </div>
                  </div>
                </div>

                {/* Right: Notes */}
                <div className="border-l border-slate-700 overflow-hidden">
                  <NotesPanel
                    notes={notes}
                    onUpdateNotes={handleUpdateNotes}
                    currentStep={currentStep}
                  />
                </div>
              </div>
            )}
          </main>

          {/* Modals */}
          <SettingsModal
            isOpen={showSettings}
            onClose={() => setShowSettings(false)}
            settings={settings}
            onSave={setSettings}
          />

          <ImportModal
            isOpen={showImport}
            onClose={() => setShowImport(false)}
            onImport={handleImportPaper}
          />
        </div>
      );
    }

    // Render
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
