<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Brainstormrr</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      background: #0d1117;
      color: #e6edf3;
    }
    #root { width: 100vw; height: 100vh; }
    ::-webkit-scrollbar { display: none; }

    .task-text { user-select: none; pointer-events: none; }

    .task-input {
      background: transparent;
      border: none;
      outline: none;
      color: inherit;
      font-size: inherit;
      text-align: center;
      width: 100%;
    }

    .context-menu {
      position: fixed;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 4px;
      min-width: 160px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      z-index: 1000;
    }

    .context-menu button {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: #e6edf3;
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      text-align: left;
    }

    .context-menu button:hover { background: #21262d; }
    .context-menu .divider { height: 1px; background: #30363d; margin: 4px 0; }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow: auto;
    }

    .modal textarea {
      width: 100%;
      min-height: 200px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px;
      color: #e6edf3;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
    }

    .modal textarea:focus { outline: none; border-color: #58a6ff; }

    .toolbar {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 8px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      z-index: 100;
    }

    .toolbar button {
      background: transparent;
      border: none;
      color: #8b949e;
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
    }

    .toolbar button:hover { background: #21262d; color: #e6edf3; }

    .legend {
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 12px 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      z-index: 100;
      max-width: calc(100vw - 32px);
    }

    .legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #8b949e; cursor: pointer; }
    .legend-item:hover { color: #e6edf3; }
    .legend-dot { width: 12px; height: 12px; border-radius: 50%; }

    .stats {
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 12px;
      color: #8b949e;
      z-index: 100;
    }

    .help-hint {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 12px;
      color: #8b949e;
      z-index: 100;
      opacity: 0.8;
    }

    .search-overlay {
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 8px;
      width: 90%;
      max-width: 400px;
      z-index: 1000;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .search-input {
      width: 100%;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px;
      color: #e6edf3;
      font-size: 14px;
    }

    .search-input:focus { outline: none; border-color: #58a6ff; }

    .search-results { margin-top: 8px; max-height: 300px; overflow-y: auto; }

    .search-result {
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .search-result:hover, .search-result.selected { background: #21262d; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef, useMemo } = React;

    // ============ CONSTANTS ============

    const SCHEMA_VERSION = 1;

    const CATEGORIES = {
      writing: { name: 'Writing', color: '#a371f7', position: { x: -400, y: -200 } },
      admin: { name: 'Admin', color: '#58a6ff', position: { x: 400, y: -200 } },
      study: { name: 'Study', color: '#3fb950', position: { x: -400, y: 200 } },
      work: { name: 'Work', color: '#db6d28', position: { x: 400, y: 200 } },
      personal: { name: 'Personal', color: '#d29922', position: { x: 0, y: -350 } },
      health: { name: 'Health', color: '#3ddbd9', position: { x: 0, y: 350 } },
      uncategorized: { name: 'Uncategorized', color: '#8b949e', position: { x: 0, y: 0 } }
    };

    const IMPORTANCE_SIZES = { 1: 50, 2: 70, 3: 100 };
    const CLUSTER_DURATION = 1200; // ms for auto-cluster animation
    const SAVE_DEBOUNCE = 500; // ms

    // ============ STORAGE ABSTRACTION ============
    // Schema-versioned for future migration support

    const Storage = {
      _key: 'brainstormrr-data',

      _migrate(data) {
        // Future migrations go here
        // if (data.schemaVersion === 1) { migrate to 2 }
        return data;
      },

      load() {
        try {
          const raw = localStorage.getItem(this._key);
          if (!raw) return this._defaultData();
          const data = JSON.parse(raw);
          return this._migrate(data);
        } catch {
          return this._defaultData();
        }
      },

      save(data) {
        localStorage.setItem(this._key, JSON.stringify({
          ...data,
          schemaVersion: SCHEMA_VERSION,
          lastModified: new Date().toISOString()
        }));
      },

      _defaultData() {
        return {
          schemaVersion: SCHEMA_VERSION,
          nodes: [],
          camera: { x: 0, y: 0, zoom: 1 },
          lastModified: null
        };
      },

      export(data) {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `brainstormrr-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
      },

      import(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (!data.schemaVersion && !data.nodes) {
                // Try legacy format
                if (Array.isArray(data.tasks)) {
                  resolve({ nodes: data.tasks, camera: { x: 0, y: 0, zoom: 1 }, schemaVersion: SCHEMA_VERSION });
                  return;
                }
                reject(new Error('Invalid file format'));
                return;
              }
              resolve(this._migrate(data));
            } catch (err) {
              reject(err);
            }
          };
          reader.onerror = reject;
          reader.readAsText(file);
        });
      }
    };

    // ============ UTILITIES ============

    const generateId = () => Math.random().toString(36).substring(2, 15);
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

    // ============ TASK NODE COMPONENT ============

    const TaskNode = ({
      node,
      isSelected,
      isEditing,
      dimmed,
      onMouseDown,
      onDoubleClick,
      onContextMenu,
      onTitleChange,
      onTitleSubmit
    }) => {
      const size = IMPORTANCE_SIZES[node.importance] || 70;
      const category = CATEGORIES[node.category] || CATEGORIES.uncategorized;
      const opacity = node.status === 'done' ? 0.2 : dimmed ? 0.3 : 1;
      const inputRef = useRef(null);

      useEffect(() => {
        if (isEditing && inputRef.current) {
          inputRef.current.focus();
          inputRef.current.select();
        }
      }, [isEditing]);

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          onTitleSubmit(node.id);
        } else if (e.key === 'Escape') {
          onTitleSubmit(node.id);
        }
      };

      return (
        <g
          transform={`translate(${node.x}, ${node.y})`}
          style={{ cursor: 'grab', opacity }}
          onMouseDown={(e) => { e.stopPropagation(); onMouseDown(e, node.id); }}
          onDoubleClick={(e) => { e.stopPropagation(); onDoubleClick(node.id); }}
          onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); onContextMenu(node.id, e); }}
        >
          {isSelected && (
            <circle r={size / 2 + 8} fill="none" stroke={category.color} strokeWidth="2" opacity="0.5" />
          )}
          <circle
            r={size / 2}
            fill={category.color}
            fillOpacity="0.15"
            stroke={category.color}
            strokeWidth="2"
          />
          {isEditing ? (
            <foreignObject x={-size / 2 + 5} y={-12} width={size - 10} height={24}>
              <input
                ref={inputRef}
                className="task-input"
                value={node.title}
                onChange={(e) => onTitleChange(node.id, e.target.value)}
                onKeyDown={handleKeyDown}
                onBlur={() => onTitleSubmit(node.id)}
                style={{ color: category.color }}
              />
            </foreignObject>
          ) : (
            <text
              className="task-text"
              textAnchor="middle"
              dominantBaseline="middle"
              fill={category.color}
              fontSize={Math.max(11, Math.min(14, size / 5))}
              fontWeight="500"
            >
              {node.title.length > 15 ? node.title.substring(0, 15) + '...' : node.title}
            </text>
          )}
          {node.status === 'done' && (
            <text y={size / 4} textAnchor="middle" fill={category.color} fontSize="16">‚úì</text>
          )}
          {/* Pin indicator for manually positioned nodes */}
          {node.layoutMode === 'manual' && (
            <circle cx={size / 2 - 6} cy={-size / 2 + 6} r="4" fill="#8b949e" opacity="0.6" />
          )}
        </g>
      );
    };

    // ============ CONTEXT MENU ============

    const ContextMenu = ({ x, y, node, onClose, onAction }) => {
      const menuRef = useRef(null);

      useEffect(() => {
        const handleClickOutside = (e) => {
          if (menuRef.current && !menuRef.current.contains(e.target)) onClose();
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, [onClose]);

      if (!node) return null;
      const category = CATEGORIES[node.category] || CATEGORIES.uncategorized;

      return (
        <div ref={menuRef} className="context-menu" style={{ left: x, top: y }}>
          <div style={{ padding: '4px 12px', fontSize: '11px', color: '#8b949e', textTransform: 'uppercase' }}>
            Importance
          </div>
          {[1, 2, 3].map(imp => (
            <button key={imp} onClick={() => onAction('importance', imp)}>
              <span style={{
                width: 16, height: 16, borderRadius: '50%',
                background: node.importance === imp ? category.color : '#30363d',
                display: 'inline-block'
              }} />
              {imp === 1 ? 'Low' : imp === 2 ? 'Medium' : 'High'}
              {node.importance === imp && ' ‚úì'}
            </button>
          ))}

          <div className="divider" />

          <div style={{ padding: '4px 12px', fontSize: '11px', color: '#8b949e', textTransform: 'uppercase' }}>
            Category
          </div>
          {Object.entries(CATEGORIES).map(([key, cat]) => (
            <button key={key} onClick={() => onAction('category', key)}>
              <span style={{ width: 12, height: 12, borderRadius: '50%', background: cat.color, display: 'inline-block' }} />
              {cat.name}
              {node.category === key && ' ‚úì'}
            </button>
          ))}

          <div className="divider" />

          <button onClick={() => onAction('status', node.status === 'done' ? 'active' : 'done')}>
            {node.status === 'done' ? '‚Ü©Ô∏è Mark Active' : '‚úì Mark Done'}
          </button>

          {node.layoutMode === 'manual' && (
            <button onClick={() => onAction('unpin')}>
              üîì Auto-arrange
            </button>
          )}

          <div className="divider" />

          <button onClick={() => onAction('delete')} style={{ color: '#f85149' }}>
            üóëÔ∏è Delete
          </button>
        </div>
      );
    };

    // ============ BRAIN DUMP MODAL ============

    const BrainDumpModal = ({ isOpen, onClose, onSubmit }) => {
      const [text, setText] = useState('');
      const textareaRef = useRef(null);

      useEffect(() => {
        if (isOpen && textareaRef.current) {
          textareaRef.current.focus();
        }
      }, [isOpen]);

      if (!isOpen) return null;

      const handleSubmit = () => {
        if (text.trim()) {
          onSubmit(text);
          setText('');
          onClose();
        }
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) handleSubmit();
        else if (e.key === 'Escape') onClose();
      };

      const parsePreview = () => {
        return text.split('\n').filter(l => l.trim()).map(line => {
          let title = line.trim();
          let category = 'uncategorized';
          let importance = 1;

          const catMatch = title.match(/\[(\w+)\]/i);
          if (catMatch) {
            const cat = catMatch[1].toLowerCase();
            if (CATEGORIES[cat]) category = cat;
            title = title.replace(catMatch[0], '').trim();
          }

          if (title.includes('!!!')) { importance = 3; title = title.replace(/!!!/g, '').trim(); }
          else if (title.includes('!!')) { importance = 2; title = title.replace(/!!/g, '').trim(); }

          return { title, category, importance };
        });
      };

      const preview = parsePreview();

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal" onClick={e => e.stopPropagation()}>
            <h2 style={{ margin: '0 0 16px', fontSize: '18px', fontWeight: '600' }}>Brain Dump</h2>
            <p style={{ margin: '0 0 16px', fontSize: '13px', color: '#8b949e' }}>
              One task per line. Use <code style={{ background: '#21262d', padding: '2px 4px', borderRadius: '4px' }}>[category]</code> and <code style={{ background: '#21262d', padding: '2px 4px', borderRadius: '4px' }}>!!!</code> for high importance.
            </p>
            <textarea
              ref={textareaRef}
              value={text}
              onChange={e => setText(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="Draft blog post [writing]&#10;Call dentist [health] !!!&#10;Review quarterly report [work]&#10;Learn React hooks [study] !!"
            />

            {preview.length > 0 && (
              <div style={{ marginTop: '16px' }}>
                <div style={{ fontSize: '12px', color: '#8b949e', marginBottom: '8px' }}>
                  Preview ({preview.length} tasks):
                </div>
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                  {preview.slice(0, 8).map((t, i) => (
                    <span key={i} style={{
                      background: CATEGORIES[t.category].color + '22',
                      color: CATEGORIES[t.category].color,
                      padding: '4px 8px',
                      borderRadius: '4px',
                      fontSize: '12px',
                      border: `1px solid ${CATEGORIES[t.category].color}44`
                    }}>
                      {t.title.substring(0, 20)}{t.title.length > 20 ? '...' : ''}
                      {t.importance > 1 && ' ' + '!'.repeat(t.importance)}
                    </span>
                  ))}
                  {preview.length > 8 && (
                    <span style={{ fontSize: '12px', color: '#8b949e' }}>+{preview.length - 8} more</span>
                  )}
                </div>
              </div>
            )}

            <div style={{ display: 'flex', gap: '12px', marginTop: '20px', justifyContent: 'flex-end' }}>
              <button onClick={onClose} style={{
                padding: '8px 16px', background: 'transparent', border: '1px solid #30363d',
                borderRadius: '6px', color: '#8b949e', cursor: 'pointer'
              }}>Cancel</button>
              <button onClick={handleSubmit} disabled={preview.length === 0} style={{
                padding: '8px 16px', background: preview.length > 0 ? '#238636' : '#21262d',
                border: 'none', borderRadius: '6px',
                color: preview.length > 0 ? '#fff' : '#8b949e',
                cursor: preview.length > 0 ? 'pointer' : 'not-allowed', fontWeight: '500'
              }}>Add {preview.length} Task{preview.length !== 1 ? 's' : ''} (‚åò‚Üµ)</button>
            </div>
          </div>
        </div>
      );
    };

    // ============ SEARCH OVERLAY (Cmd+K to jump) ============

    const SearchOverlay = ({ isOpen, onClose, nodes, onSelect }) => {
      const [query, setQuery] = useState('');
      const [selectedIndex, setSelectedIndex] = useState(0);
      const inputRef = useRef(null);

      useEffect(() => {
        if (isOpen) {
          setQuery('');
          setSelectedIndex(0);
          inputRef.current?.focus();
        }
      }, [isOpen]);

      if (!isOpen) return null;

      const results = query.trim()
        ? nodes.filter(n => n.title.toLowerCase().includes(query.toLowerCase())).slice(0, 10)
        : [];

      const handleKeyDown = (e) => {
        if (e.key === 'Escape') onClose();
        else if (e.key === 'ArrowDown') {
          e.preventDefault();
          setSelectedIndex(i => Math.min(i + 1, results.length - 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          setSelectedIndex(i => Math.max(i - 1, 0));
        } else if (e.key === 'Enter' && results[selectedIndex]) {
          onSelect(results[selectedIndex]);
          onClose();
        }
      };

      return (
        <div className="search-overlay">
          <input
            ref={inputRef}
            className="search-input"
            value={query}
            onChange={e => { setQuery(e.target.value); setSelectedIndex(0); }}
            onKeyDown={handleKeyDown}
            placeholder="Search tasks... (‚Üµ to jump)"
          />
          {results.length > 0 && (
            <div className="search-results">
              {results.map((node, i) => {
                const cat = CATEGORIES[node.category] || CATEGORIES.uncategorized;
                return (
                  <div
                    key={node.id}
                    className={`search-result ${i === selectedIndex ? 'selected' : ''}`}
                    onClick={() => { onSelect(node); onClose(); }}
                  >
                    <span style={{ width: 10, height: 10, borderRadius: '50%', background: cat.color }} />
                    <span>{node.title}</span>
                    {node.status === 'done' && <span style={{ color: '#8b949e', marginLeft: 'auto' }}>‚úì</span>}
                  </div>
                );
              })}
            </div>
          )}
          {query && results.length === 0 && (
            <div style={{ padding: '12px', color: '#8b949e', fontSize: '13px' }}>No tasks found</div>
          )}
        </div>
      );
    };

    // ============ MAIN APP ============

    const App = () => {
      // Load initial state from storage
      const initialData = useMemo(() => Storage.load(), []);

      const [nodes, setNodes] = useState(initialData.nodes);
      const [camera, setCamera] = useState(initialData.camera);
      const [selectedIds, setSelectedIds] = useState(new Set());
      const [editingId, setEditingId] = useState(null);
      const [contextMenu, setContextMenu] = useState(null);
      const [brainDumpOpen, setBrainDumpOpen] = useState(false);
      const [searchOpen, setSearchOpen] = useState(false);
      const [showHelp, setShowHelp] = useState(nodes.length === 0);
      const [focusMode, setFocusMode] = useState(null); // category to focus on

      // Refs for imperative updates during drag/pan (performance optimization)
      const svgRef = useRef(null);
      const dragRef = useRef(null);
      const panRef = useRef(null);
      const saveTimeoutRef = useRef(null);
      const clusterAnimRef = useRef(null);

      // Debounced save
      useEffect(() => {
        clearTimeout(saveTimeoutRef.current);
        saveTimeoutRef.current = setTimeout(() => {
          Storage.save({ nodes, camera });
        }, SAVE_DEBOUNCE);
        return () => clearTimeout(saveTimeoutRef.current);
      }, [nodes, camera]);

      // Save on visibility change (tab close/switch)
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.visibilityState === 'hidden') {
            Storage.save({ nodes, camera });
          }
        };
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [nodes, camera]);

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Don't trigger shortcuts when typing in inputs
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          if (e.key === 'k' && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            setSearchOpen(true);
            return;
          }
          if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'n') {
            e.preventDefault();
            setBrainDumpOpen(true);
            return;
          }
          if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
            e.preventDefault();
            addNode(0, 0);
            return;
          }
          if ((e.key === 'Backspace' || e.key === 'Delete') && selectedIds.size > 0 && !editingId) {
            e.preventDefault();
            setNodes(n => n.filter(node => !selectedIds.has(node.id)));
            setSelectedIds(new Set());
            return;
          }
          if (e.key === 'Escape') {
            setSelectedIds(new Set());
            setEditingId(null);
            setContextMenu(null);
            setBrainDumpOpen(false);
            setSearchOpen(false);
            setFocusMode(null);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedIds, editingId]);

      // ============ PAN & ZOOM ============

      const handleCanvasMouseDown = (e) => {
        if (e.button === 0 && !e.altKey && e.target === svgRef.current) {
          // Click on empty canvas - deselect unless shift held
          if (!e.shiftKey) setSelectedIds(new Set());
          setEditingId(null);
          setContextMenu(null);
        }
        // Middle click, Alt+click, or Space+click to pan
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
          panRef.current = { startX: e.clientX, startY: e.clientY, origX: camera.x, origY: camera.y };
        }
      };

      const handleMouseMove = useCallback((e) => {
        if (panRef.current) {
          const dx = e.clientX - panRef.current.startX;
          const dy = e.clientY - panRef.current.startY;
          setCamera(c => ({ ...c, x: panRef.current.origX + dx, y: panRef.current.origY + dy }));
        } else if (dragRef.current) {
          const dx = (e.clientX - dragRef.current.startX) / camera.zoom;
          const dy = (e.clientY - dragRef.current.startY) / camera.zoom;
          setNodes(n => n.map(node =>
            dragRef.current.ids.has(node.id)
              ? { ...node, x: dragRef.current.orig[node.id].x + dx, y: dragRef.current.orig[node.id].y + dy }
              : node
          ));
        }
      }, [camera.zoom]);

      const handleMouseUp = useCallback(() => {
        if (dragRef.current) {
          // Mark dragged nodes as manually positioned (pinned)
          setNodes(n => n.map(node =>
            dragRef.current.ids.has(node.id)
              ? { ...node, layoutMode: 'manual' }
              : node
          ));
        }
        panRef.current = null;
        dragRef.current = null;
      }, []);

      // Zoom with scroll wheel (zoom to cursor position)
      const handleWheel = useCallback((e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = clamp(camera.zoom * delta, 0.2, 3);
        const rect = svgRef.current.getBoundingClientRect();
        const cx = e.clientX - rect.width / 2;
        const cy = e.clientY - rect.height / 2;
        const scale = newZoom / camera.zoom;
        setCamera(c => ({
          x: cx - scale * (cx - c.x),
          y: cy - scale * (cy - c.y),
          zoom: newZoom
        }));
      }, [camera]);

      useEffect(() => {
        const svg = svgRef.current;
        if (svg) {
          svg.addEventListener('wheel', handleWheel, { passive: false });
          return () => svg.removeEventListener('wheel', handleWheel);
        }
      }, [handleWheel]);

      // ============ NODE OPERATIONS ============

      const addNode = (x, y, props = {}) => {
        const newNode = {
          id: generateId(),
          title: 'New task',
          x, y,
          importance: 2,
          category: 'uncategorized',
          status: 'active',
          layoutMode: (x !== 0 || y !== 0) ? 'manual' : 'auto',
          createdAt: new Date().toISOString(),
          ...props
        };
        setNodes(n => [...n, newNode]);
        setSelectedIds(new Set([newNode.id]));
        setEditingId(newNode.id);
        setShowHelp(false);
        return newNode;
      };

      const addBrainDumpNodes = (text) => {
        const lines = text.split('\n').filter(l => l.trim());
        const newNodes = lines.map((line, i) => {
          let title = line.trim();
          let category = 'uncategorized';
          let importance = 1;

          const catMatch = title.match(/\[(\w+)\]/i);
          if (catMatch) {
            const cat = catMatch[1].toLowerCase();
            if (CATEGORIES[cat]) category = cat;
            title = title.replace(catMatch[0], '').trim();
          }

          if (title.includes('!!!')) { importance = 3; title = title.replace(/!!!/g, '').trim(); }
          else if (title.includes('!!')) { importance = 2; title = title.replace(/!!/g, '').trim(); }

          // Spread in a circle from center
          const angle = (i / lines.length) * 2 * Math.PI;
          const radius = 80 + Math.random() * 60;

          return {
            id: generateId(),
            title: title || 'Untitled',
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            importance,
            category,
            status: 'active',
            layoutMode: 'auto',
            createdAt: new Date().toISOString()
          };
        });

        setNodes(n => [...n, ...newNodes]);
        setShowHelp(false);
        // Trigger auto-cluster after short delay
        setTimeout(() => autoCluster(), 100);
      };

      // ============ AUTO-CLUSTER (One-shot animation, NOT continuous physics) ============
      // Per ChatGPT feedback: no continuous drift - just a one-click "cluster" action

      const autoCluster = useCallback(() => {
        setNodes(currentNodes => {
          const toAnimate = currentNodes.filter(n => n.layoutMode !== 'manual');
          if (toAnimate.length === 0) return currentNodes;

          const startPositions = {};
          const targetPositions = {};

          // Group by category and calculate target positions
          const categoryGroups = {};
          toAnimate.forEach(n => {
            if (!categoryGroups[n.category]) categoryGroups[n.category] = [];
            categoryGroups[n.category].push(n);
            startPositions[n.id] = { x: n.x, y: n.y };
          });

          // Calculate target positions with collision avoidance
          Object.entries(categoryGroups).forEach(([catKey, catNodes]) => {
            const cat = CATEGORIES[catKey] || CATEGORIES.uncategorized;
            catNodes.forEach((n, i) => {
              const angle = (i / catNodes.length) * 2 * Math.PI + Math.random() * 0.5;
              const radius = 30 + i * 25 + Math.random() * 30;
              targetPositions[n.id] = {
                x: cat.position.x + Math.cos(angle) * radius,
                y: cat.position.y + Math.sin(angle) * radius
              };
            });
          });

          // Animate
          const startTime = performance.now();
          const animate = (now) => {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / CLUSTER_DURATION, 1);
            const eased = easeOutCubic(progress);

            setNodes(current => current.map(node => {
              if (node.layoutMode === 'manual' || !startPositions[node.id]) return node;
              const start = startPositions[node.id];
              const target = targetPositions[node.id];
              return {
                ...node,
                x: start.x + (target.x - start.x) * eased,
                y: start.y + (target.y - start.y) * eased
              };
            }));

            if (progress < 1) {
              clusterAnimRef.current = requestAnimationFrame(animate);
            }
          };

          cancelAnimationFrame(clusterAnimRef.current);
          clusterAnimRef.current = requestAnimationFrame(animate);
          return currentNodes;
        });
      }, []);

      const handleNodeMouseDown = (e, nodeId) => {
        if (e.button === 2) return; // Right click handled by context menu

        // Selection logic
        if (e.shiftKey) {
          setSelectedIds(s => {
            const newSet = new Set(s);
            if (newSet.has(nodeId)) newSet.delete(nodeId);
            else newSet.add(nodeId);
            return newSet;
          });
        } else if (!selectedIds.has(nodeId)) {
          setSelectedIds(new Set([nodeId]));
        }

        // Start drag for selected nodes
        const ids = e.shiftKey ? selectedIds : (selectedIds.has(nodeId) ? selectedIds : new Set([nodeId]));
        if (!ids.has(nodeId)) ids.add(nodeId);

        const orig = {};
        nodes.forEach(n => {
          if (ids.has(n.id)) orig[n.id] = { x: n.x, y: n.y };
        });
        dragRef.current = { ids, startX: e.clientX, startY: e.clientY, orig };
      };

      const handleDoubleClick = (e) => {
        if (e.target === svgRef.current) {
          const rect = svgRef.current.getBoundingClientRect();
          const x = (e.clientX - rect.width / 2 - camera.x) / camera.zoom;
          const y = (e.clientY - rect.height / 2 - camera.y) / camera.zoom;
          addNode(x, y);
        }
      };

      const handleContextMenuAction = (action, value) => {
        if (!contextMenu) return;
        const nodeId = contextMenu.nodeId;

        if (action === 'delete') {
          setNodes(n => n.filter(node => node.id !== nodeId));
          setSelectedIds(s => { const ns = new Set(s); ns.delete(nodeId); return ns; });
        } else if (action === 'unpin') {
          setNodes(n => n.map(node => node.id === nodeId ? { ...node, layoutMode: 'auto' } : node));
          setTimeout(() => autoCluster(), 50);
        } else if (action === 'category') {
          // When changing category, unpin so it can drift to new zone
          setNodes(n => n.map(node =>
            node.id === nodeId ? { ...node, category: value, layoutMode: 'auto' } : node
          ));
          setTimeout(() => autoCluster(), 50);
        } else {
          setNodes(n => n.map(node => node.id === nodeId ? { ...node, [action]: value } : node));
        }
        setContextMenu(null);
      };

      const fitAll = () => {
        if (nodes.length === 0) return;
        const padding = 150;
        const xs = nodes.map(n => n.x);
        const ys = nodes.map(n => n.y);
        const minX = Math.min(...xs) - padding;
        const maxX = Math.max(...xs) + padding;
        const minY = Math.min(...ys) - padding;
        const maxY = Math.max(...ys) + padding;
        const width = maxX - minX;
        const height = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const rect = svgRef.current?.getBoundingClientRect();
        if (!rect) return;
        const zoom = Math.min(rect.width / width, rect.height / height, 2);
        setCamera({ x: -centerX * zoom, y: -centerY * zoom, zoom });
      };

      const jumpToNode = (node) => {
        setCamera(c => ({
          ...c,
          x: -node.x * c.zoom,
          y: -node.y * c.zoom
        }));
        setSelectedIds(new Set([node.id]));
      };

      const handleExport = () => Storage.export({ nodes, camera, schemaVersion: SCHEMA_VERSION });

      const handleImport = async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              const data = await Storage.import(file);
              setNodes(data.nodes || []);
              setCamera(data.camera || { x: 0, y: 0, zoom: 1 });
              setShowHelp(false);
            } catch (err) {
              alert('Failed to import: ' + err.message);
            }
          }
        };
        input.click();
      };

      // Stats
      const activeCount = nodes.filter(n => n.status === 'active').length;
      const doneCount = nodes.filter(n => n.status === 'done').length;

      return (
        <div
          style={{ width: '100%', height: '100%', position: 'relative' }}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
        >
          {/* Toolbar */}
          <div className="toolbar">
            <button onClick={() => addNode(0, 0)} title="New Task (‚åòN)">‚ûï New</button>
            <button onClick={() => setBrainDumpOpen(true)} title="Brain Dump (‚åò‚áßN)">üß† Dump</button>
            <button onClick={() => setSearchOpen(true)} title="Search (‚åòK)">üîç Find</button>
            <button onClick={fitAll} title="Fit All">üéØ Fit</button>
            <button onClick={autoCluster} title="Auto-arrange unpinned tasks">üîÑ Cluster</button>
            <button onClick={handleExport} title="Export JSON">üì§</button>
            <button onClick={handleImport} title="Import JSON">üì•</button>
          </div>

          {/* Help hint */}
          {showHelp && (
            <div className="help-hint">
              Double-click to add ‚Ä¢ Scroll to zoom ‚Ä¢ Alt+drag to pan ‚Ä¢ ‚åòK to search
            </div>
          )}

          {/* SVG Canvas */}
          <svg
            ref={svgRef}
            width="100%"
            height="100%"
            style={{
              cursor: panRef.current ? 'grabbing' : dragRef.current ? 'grabbing' : 'default',
              background: '#0d1117'
            }}
            onMouseDown={handleCanvasMouseDown}
            onDoubleClick={handleDoubleClick}
            onContextMenu={(e) => e.preventDefault()}
          >
            <defs>
              <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                <circle cx="25" cy="25" r="1" fill="#21262d" />
              </pattern>
            </defs>

            <g transform={`translate(${window.innerWidth / 2 + camera.x}, ${window.innerHeight / 2 + camera.y}) scale(${camera.zoom})`}>
              <rect x="-5000" y="-5000" width="10000" height="10000" fill="url(#grid)" />

              {/* Category zone indicators */}
              {Object.entries(CATEGORIES).map(([key, cat]) => (
                <g
                  key={key}
                  transform={`translate(${cat.position.x}, ${cat.position.y})`}
                  opacity={focusMode && focusMode !== key ? 0.1 : 0.3}
                  style={{ cursor: 'pointer' }}
                  onClick={() => setFocusMode(f => f === key ? null : key)}
                >
                  <circle r="150" fill={cat.color} fillOpacity="0.05" stroke={cat.color} strokeWidth="1" strokeDasharray="5,5" />
                  <text y="170" textAnchor="middle" fill={cat.color} fontSize="12" fontWeight="500">
                    {cat.name}
                  </text>
                </g>
              ))}

              {/* Task nodes */}
              {nodes.map(node => (
                <TaskNode
                  key={node.id}
                  node={node}
                  isSelected={selectedIds.has(node.id)}
                  isEditing={editingId === node.id}
                  dimmed={focusMode && node.category !== focusMode}
                  onMouseDown={handleNodeMouseDown}
                  onDoubleClick={(id) => setEditingId(id)}
                  onContextMenu={(id, e) => setContextMenu({ nodeId: id, x: e.clientX, y: e.clientY })}
                  onTitleChange={(id, title) => setNodes(n => n.map(node => node.id === id ? { ...node, title } : node))}
                  onTitleSubmit={() => setEditingId(null)}
                />
              ))}
            </g>
          </svg>

          {/* Legend - clickable to focus */}
          <div className="legend">
            {Object.entries(CATEGORIES).filter(([k]) => k !== 'uncategorized').map(([key, cat]) => (
              <div
                key={key}
                className="legend-item"
                style={{ opacity: focusMode && focusMode !== key ? 0.4 : 1 }}
                onClick={() => setFocusMode(f => f === key ? null : key)}
                title={`Click to focus on ${cat.name}`}
              >
                <span className="legend-dot" style={{ background: cat.color }} />
                {cat.name}
              </div>
            ))}
          </div>

          {/* Stats */}
          <div className="stats">
            {activeCount} active ‚Ä¢ {doneCount} done
          </div>

          {/* Context Menu */}
          {contextMenu && (
            <ContextMenu
              x={contextMenu.x}
              y={contextMenu.y}
              node={nodes.find(n => n.id === contextMenu.nodeId)}
              onClose={() => setContextMenu(null)}
              onAction={handleContextMenuAction}
            />
          )}

          {/* Brain Dump Modal */}
          <BrainDumpModal
            isOpen={brainDumpOpen}
            onClose={() => setBrainDumpOpen(false)}
            onSubmit={addBrainDumpNodes}
          />

          {/* Search Overlay */}
          <SearchOverlay
            isOpen={searchOpen}
            onClose={() => setSearchOpen(false)}
            nodes={nodes}
            onSelect={jumpToNode}
          />
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
