<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Memo Transcriber</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1f1f1f;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #2a2a2a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container { max-width: 900px; margin: 0 auto; padding: 2rem; }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        h1 { font-size: 1.75rem; font-weight: 600; }

        .header-right { display: flex; align-items: center; gap: 1rem; }

        .server-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error);
        }

        .status-dot.connected { background: var(--success); }

        .notify-btn {
            padding: 0.4rem 0.8rem;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
        }

        .notify-btn.enabled {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .server-notice {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid var(--warning);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.875rem;
        }

        .server-notice code {
            background: var(--bg-tertiary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 3rem 2rem;
            text-align: center;
            margin-bottom: 2rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.05);
        }

        .drop-zone.has-file {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.05);
        }

        .drop-zone h2 { font-size: 1.25rem; margin-bottom: 0.5rem; }
        .drop-zone p { color: var(--text-secondary); font-size: 0.875rem; }
        .drop-zone input { display: none; }

        .file-info {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            text-align: left;
        }

        .file-info .filename { font-weight: 600; margin-bottom: 0.5rem; }
        .file-info .meta { font-size: 0.875rem; color: var(--text-secondary); }

        .duplicate-warning {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(245, 158, 11, 0.1);
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--warning);
        }

        /* Options Panel */
        .options-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .options-panel h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .option-group { display: flex; flex-direction: column; gap: 0.5rem; }
        .option-group label { font-size: 0.875rem; color: var(--text-secondary); }

        .option-group select, .option-group input[type="range"] {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .checkbox-group { display: flex; align-items: center; gap: 0.75rem; }
        .checkbox-group input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent); }
        .speed-value { font-size: 0.875rem; color: var(--accent); font-weight: 600; }

        /* Transcription Options */
        .transcribe-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .transcribe-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .transcribe-card:hover { border-color: var(--accent); }
        .transcribe-card.selected { border-color: var(--accent); background: rgba(59, 130, 246, 0.1); }
        .transcribe-card.disabled { opacity: 0.5; cursor: not-allowed; }

        .transcribe-card h4 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .transcribe-card .badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            background: var(--success);
            color: white;
        }

        .transcribe-card .badge.paid { background: var(--warning); }
        .transcribe-card p { font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem; }

        .estimate {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .estimate .time { color: var(--text-primary); }
        .estimate .cost { color: var(--success); font-weight: 600; }
        .estimate .cost.paid { color: var(--warning); }

        .model-select-wrapper {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .model-select-wrapper label { display: block; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .model-select-wrapper select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        /* Transcribe Button */
        .transcribe-btn {
            width: 100%;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 2rem;
        }

        .transcribe-btn:hover:not(:disabled) { background: var(--accent-hover); }
        .transcribe-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Live Status Panel */
        .status-panel {
            display: none;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .status-panel.visible { display: block; }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .status-header h3 { font-size: 1.1rem; }

        .status-badge {
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-badge.queued { background: var(--bg-tertiary); color: var(--text-secondary); }
        .status-badge.preprocessing { background: rgba(59, 130, 246, 0.2); color: var(--accent); }
        .status-badge.transcribing { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .status-badge.completed { background: rgba(34, 197, 94, 0.2); color: var(--success); }
        .status-badge.error { background: rgba(239, 68, 68, 0.2); color: var(--error); }

        .progress-section { margin-bottom: 1rem; }

        .progress-bar {
            height: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--success));
            transition: width 0.3s;
            width: 0%;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .progress-percent { font-weight: 600; color: var(--text-primary); }

        .status-details {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.875rem;
        }

        .status-details .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
        }

        .status-details .detail-label { color: var(--text-secondary); }

        /* Result Panel */
        .result-panel {
            display: none;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .result-panel.visible { display: block; }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .result-header h3 { font-size: 1.1rem; }
        .result-actions { display: flex; gap: 0.5rem; }

        .result-meta {
            display: flex;
            gap: 1.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .transcript-box {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1.5rem;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.9rem;
            line-height: 1.8;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--border); }

        /* Toast */
        .toast-container { position: fixed; bottom: 2rem; right: 2rem; z-index: 1000; }
        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-top: 0.5rem;
            animation: slideIn 0.3s ease;
        }
        .toast-success { border-color: var(--success); }
        .toast-error { border-color: var(--error); }
        .toast-warning { border-color: var(--warning); }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* History */
        .history-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
        }

        .history-section h3 { font-size: 1.1rem; margin-bottom: 1rem; }

        .history-item {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item .info { flex: 1; }
        .history-item .filename { font-weight: 500; }
        .history-item .meta { font-size: 0.8rem; color: var(--text-secondary); }

        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .transcribe-options { grid-template-columns: 1fr; }
            .options-grid { grid-template-columns: 1fr; }
            .header-right { flex-direction: column; gap: 0.5rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Voice Memo Transcriber</h1>
            <div class="header-right">
                <button class="notify-btn" id="notify-btn" onclick="toggleNotifications()">
                    Notifications: Off
                </button>
                <div class="server-status">
                    <span class="status-dot" id="status-dot"></span>
                    <span id="status-text">Checking...</span>
                </div>
            </div>
        </header>

        <div class="server-notice" id="server-notice" style="display: none;">
            <strong>Local server not running.</strong> Start it with:
            <code>launch voice</code> or <code>python server.py</code>
        </div>

        <!-- Drop Zone -->
        <div class="drop-zone" id="drop-zone">
            <h2>Drop audio file here</h2>
            <p>or click to browse (mp3, m4a, wav, etc.)</p>
            <input type="file" id="file-input" accept="audio/*">
            <div class="file-info" id="file-info" style="display: none;">
                <div class="filename" id="filename"></div>
                <div class="meta" id="file-meta"></div>
                <div class="duplicate-warning" id="duplicate-warning" style="display: none;">
                    This file was transcribed before. Processing again with current settings.
                </div>
            </div>
        </div>

        <!-- Preprocessing Options -->
        <div class="options-panel">
            <h3>Preprocessing Options</h3>
            <div class="options-grid">
                <div class="option-group">
                    <label>Playback Speed</label>
                    <input type="range" id="speed-slider" min="1" max="2" step="0.25" value="1">
                    <span class="speed-value" id="speed-value">1.0x (normal)</span>
                </div>
                <div class="option-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="remove-silence" checked>
                        <label for="remove-silence">Remove silence (faster)</label>
                    </div>
                </div>
                <div class="option-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="compress" checked>
                        <label for="compress">Compress audio (16kHz mono)</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Transcription Options -->
        <div class="transcribe-options">
            <div class="transcribe-card selected" id="card-local" onclick="selectMethod('local')">
                <h4>Local (MLX Whisper) <span class="badge">Free</span></h4>
                <p>Runs on your Mac. Private - audio never leaves your device.</p>
                <div class="estimate">
                    <span class="time" id="local-time">~2 min</span>
                    <span class="cost">$0.00</span>
                </div>
                <div class="model-select-wrapper">
                    <label>Model</label>
                    <select id="mlx-model">
                        <option value="large-v3" selected>Large V3 (Best quality)</option>
                        <option value="large-v3-turbo">Large V3 Turbo (Faster)</option>
                        <option value="medium">Medium (Balanced)</option>
                        <option value="small">Small (Quick)</option>
                    </select>
                </div>
            </div>

            <div class="transcribe-card" id="card-openai" onclick="selectMethod('openai')">
                <h4>OpenAI (Cloud) <span class="badge paid">Paid</span></h4>
                <p>Uses OpenAI's Whisper API. Fast, requires API key.</p>
                <div class="estimate">
                    <span class="time" id="openai-time">~30 sec</span>
                    <span class="cost paid" id="openai-cost">$0.12</span>
                </div>
            </div>
        </div>

        <!-- Transcribe Button -->
        <button class="transcribe-btn" id="transcribe-btn" disabled>
            Select an audio file to transcribe
        </button>

        <!-- Live Status Panel -->
        <div class="status-panel" id="status-panel">
            <div class="status-header">
                <h3 id="status-filename">Processing...</h3>
                <span class="status-badge" id="job-status">queued</span>
            </div>
            <div class="progress-section">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-info">
                    <span id="progress-message">Starting...</span>
                    <span class="progress-percent" id="progress-percent">0%</span>
                </div>
            </div>
            <div class="status-details">
                <div class="detail-row">
                    <span class="detail-label">Duration</span>
                    <span id="detail-duration">-</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Elapsed</span>
                    <span id="detail-elapsed">0s</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Job ID</span>
                    <span id="detail-job-id">-</span>
                </div>
            </div>
        </div>

        <!-- Result -->
        <div class="result-panel" id="result-panel">
            <div class="result-header">
                <h3>Transcript</h3>
                <div class="result-actions">
                    <button class="btn btn-primary" onclick="copyTranscript()">Copy</button>
                    <button class="btn btn-secondary" onclick="downloadTranscript()">Download</button>
                    <button class="btn btn-secondary" onclick="resetUI()">New File</button>
                </div>
            </div>
            <div class="result-meta">
                <span id="result-words">0 words</span>
                <span id="result-time">Transcribed in 0s</span>
                <span id="result-method">via Local</span>
            </div>
            <div class="transcript-box" id="transcript-box"></div>
        </div>

        <!-- History -->
        <div class="history-section" id="history-section" style="display: none;">
            <h3>Recent Transcripts</h3>
            <div id="history-list"></div>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script>
        const LOCAL_SERVER = 'http://localhost:5111';
        const SUPABASE_URL = 'https://ydwjzlikslebokuxzwco.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inlkd2p6bGlrc2xlYm9rdXh6d2NvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg4NTEwODAsImV4cCI6MjA4NDQyNzA4MH0.CUPTmjww31xOS0-qknpQHByC3ACZ4lk1CiBcVZXHThU';

        let supabaseClient = null;
        let currentFile = null;
        let currentMethod = 'local';
        let serverAvailable = false;
        let estimates = null;
        let notificationsEnabled = false;
        let processedFiles = new Set();
        let jobStartTime = null;
        let elapsedInterval = null;

        document.addEventListener('DOMContentLoaded', () => {
            supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            setupEventListeners();
            checkServerStatus();
            loadHistory();
            checkNotificationPermission();
        });

        function setupEventListeners() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(event => {
                dropZone.addEventListener(event, e => { e.preventDefault(); e.stopPropagation(); });
                document.body.addEventListener(event, e => { e.preventDefault(); e.stopPropagation(); });
            });

            ['dragenter', 'dragover'].forEach(event => {
                dropZone.addEventListener(event, () => dropZone.classList.add('drag-over'));
            });
            ['dragleave', 'drop'].forEach(event => {
                dropZone.addEventListener(event, () => dropZone.classList.remove('drag-over'));
            });

            dropZone.addEventListener('drop', e => handleFile(e.dataTransfer.files[0]));
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

            document.getElementById('speed-slider').addEventListener('input', function() {
                const speed = parseFloat(this.value);
                const labels = { 1: '1.0x (normal)', 1.25: '1.25x', 1.5: '1.5x', 1.75: '1.75x', 2: '2.0x (fast)' };
                document.getElementById('speed-value').textContent = labels[speed] || `${speed}x`;
                updateEstimates();
            });

            document.getElementById('remove-silence').addEventListener('change', updateEstimates);
            document.getElementById('compress').addEventListener('change', updateEstimates);
            document.getElementById('mlx-model').addEventListener('change', updateEstimates);
            document.getElementById('transcribe-btn').addEventListener('click', startTranscription);
        }

        async function checkServerStatus() {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const serverNotice = document.getElementById('server-notice');

            try {
                const response = await fetch(`${LOCAL_SERVER}/health`);
                if (response.ok) {
                    const data = await response.json();
                    serverAvailable = true;
                    statusDot.classList.add('connected');
                    statusText.textContent = `Connected${data.active_jobs ? ` (${data.active_jobs} active)` : ''}`;
                    serverNotice.style.display = 'none';
                }
            } catch (e) {
                serverAvailable = false;
                statusDot.classList.remove('connected');
                statusText.textContent = 'Offline';
                serverNotice.style.display = 'block';
                if (currentMethod === 'local') selectMethod('openai');
                document.getElementById('card-local').classList.add('disabled');
            }
        }

        function checkNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'granted') {
                notificationsEnabled = true;
                updateNotifyButton();
            }
        }

        async function toggleNotifications() {
            if (!('Notification' in window)) {
                showToast('Notifications not supported', 'error');
                return;
            }

            if (Notification.permission === 'granted') {
                notificationsEnabled = !notificationsEnabled;
            } else if (Notification.permission !== 'denied') {
                const permission = await Notification.requestPermission();
                notificationsEnabled = permission === 'granted';
            } else {
                showToast('Notifications blocked. Enable in browser settings.', 'warning');
                return;
            }

            updateNotifyButton();
        }

        function updateNotifyButton() {
            const btn = document.getElementById('notify-btn');
            if (notificationsEnabled) {
                btn.textContent = 'Notifications: On';
                btn.classList.add('enabled');
            } else {
                btn.textContent = 'Notifications: Off';
                btn.classList.remove('enabled');
            }
        }

        function sendNotification(title, body) {
            if (notificationsEnabled && 'Notification' in window && Notification.permission === 'granted') {
                new Notification(title, { body, icon: 'ðŸŽ™ï¸' });
            }
        }

        function selectMethod(method) {
            if (method === 'local' && !serverAvailable) {
                showToast('Local server not running', 'warning');
                return;
            }
            currentMethod = method;
            document.querySelectorAll('.transcribe-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`card-${method === 'local' ? 'local' : 'openai'}`).classList.add('selected');
            updateTranscribeButton();
        }

        async function handleFile(file) {
            if (!file) return;
            if (!file.type.startsWith('audio/') && !isAudioExtension(file.name)) {
                showToast('Please select an audio file', 'error');
                return;
            }

            currentFile = file;
            document.getElementById('drop-zone').classList.add('has-file');
            document.getElementById('file-info').style.display = 'block';
            document.getElementById('filename').textContent = file.name;

            const duration = await getAudioDuration(file);
            currentFile.duration = duration;
            document.getElementById('file-meta').textContent = `${(duration / 60).toFixed(1)} min | ${(file.size / 1024 / 1024).toFixed(1)} MB`;

            // Check for duplicate
            const isDuplicate = processedFiles.has(file.name);
            document.getElementById('duplicate-warning').style.display = isDuplicate ? 'block' : 'none';

            updateEstimates();
            updateTranscribeButton();
        }

        function isAudioExtension(filename) {
            return ['mp3', 'm4a', 'wav', 'ogg', 'flac', 'aac', 'wma', 'opus', 'webm'].includes(
                filename.split('.').pop().toLowerCase()
            );
        }

        function getAudioDuration(file) {
            return new Promise(resolve => {
                const audio = new Audio();
                audio.onloadedmetadata = () => resolve(audio.duration);
                audio.onerror = () => resolve(0);
                audio.src = URL.createObjectURL(file);
            });
        }

        function updateEstimates() {
            if (!currentFile?.duration) return;

            const duration = currentFile.duration;
            const speed = parseFloat(document.getElementById('speed-slider').value);
            const removeSilence = document.getElementById('remove-silence').checked;

            let effectiveDuration = duration / speed;
            if (removeSilence) effectiveDuration *= 0.8;

            const model = document.getElementById('mlx-model').value;
            const modelFactors = { 'large-v3': 0.1, 'large-v3-turbo': 0.07, 'medium': 0.15, 'small': 0.08 };
            const mlxTime = effectiveDuration * (modelFactors[model] || 0.1);
            const openaiTime = 30 + (effectiveDuration / 60) * 2;
            const openaiCost = (duration / 60) * 0.006;

            document.getElementById('local-time').textContent = formatTime(mlxTime);
            document.getElementById('openai-time').textContent = formatTime(openaiTime);
            document.getElementById('openai-cost').textContent = `$${openaiCost.toFixed(2)}`;

            estimates = { mlxTime, openaiTime, openaiCost };
        }

        function formatTime(seconds) {
            if (seconds < 60) return `~${Math.round(seconds)} sec`;
            return `~${(seconds / 60).toFixed(1)} min`;
        }

        function updateTranscribeButton() {
            const btn = document.getElementById('transcribe-btn');
            if (!currentFile) {
                btn.disabled = true;
                btn.textContent = 'Select an audio file to transcribe';
            } else if (currentMethod === 'local' && !serverAvailable) {
                btn.disabled = true;
                btn.textContent = 'Start local server to use MLX';
            } else {
                btn.disabled = false;
                btn.textContent = `Transcribe with ${currentMethod === 'local' ? 'MLX Whisper' : 'OpenAI'}`;
            }
        }

        async function startTranscription() {
            if (!currentFile) return;

            const btn = document.getElementById('transcribe-btn');
            btn.disabled = true;

            if (currentMethod === 'local') {
                await transcribeWithServer();
            } else {
                await transcribeWithOpenAI();
            }
        }

        async function transcribeWithServer() {
            const statusPanel = document.getElementById('status-panel');
            statusPanel.classList.add('visible');
            document.getElementById('status-filename').textContent = currentFile.name;

            const formData = new FormData();
            formData.append('file', currentFile);
            formData.append('method', 'mlx');
            formData.append('model', document.getElementById('mlx-model').value);
            formData.append('speed', document.getElementById('speed-slider').value);
            formData.append('remove_silence', document.getElementById('remove-silence').checked);
            formData.append('compress', document.getElementById('compress').checked);

            try {
                // Start transcription job
                const response = await fetch(`${LOCAL_SERVER}/transcribe`, { method: 'POST', body: formData });
                const data = await response.json();

                if (data.error) throw new Error(data.error);

                const jobId = data.job_id;
                document.getElementById('detail-job-id').textContent = jobId;

                // Start elapsed timer
                jobStartTime = Date.now();
                elapsedInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - jobStartTime) / 1000);
                    document.getElementById('detail-elapsed').textContent = formatElapsed(elapsed);
                }, 1000);

                // Subscribe to SSE for progress updates
                const eventSource = new EventSource(`${LOCAL_SERVER}/progress/${jobId}`);

                eventSource.onmessage = (event) => {
                    const job = JSON.parse(event.data);
                    updateStatusPanel(job);

                    if (job.status === 'completed') {
                        eventSource.close();
                        clearInterval(elapsedInterval);
                        processedFiles.add(currentFile.name);
                        showResult(job.result);
                        saveToSupabase(job.result);
                        sendNotification('Transcription Complete', `${job.result.word_count} words transcribed`);
                    } else if (job.status === 'error') {
                        eventSource.close();
                        clearInterval(elapsedInterval);
                        showToast(`Error: ${job.error}`, 'error');
                        statusPanel.classList.remove('visible');
                        document.getElementById('transcribe-btn').disabled = false;
                    }
                };

                eventSource.onerror = () => {
                    eventSource.close();
                    clearInterval(elapsedInterval);
                    // Check job status one more time
                    fetch(`${LOCAL_SERVER}/job/${jobId}`)
                        .then(r => r.json())
                        .then(job => {
                            if (job.status === 'completed') {
                                processedFiles.add(currentFile.name);
                                showResult(job.result);
                                saveToSupabase(job.result);
                            }
                        });
                };

            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
                statusPanel.classList.remove('visible');
                document.getElementById('transcribe-btn').disabled = false;
            }
        }

        function updateStatusPanel(job) {
            document.getElementById('job-status').textContent = job.status;
            document.getElementById('job-status').className = `status-badge ${job.status}`;
            document.getElementById('progress-fill').style.width = `${job.progress}%`;
            document.getElementById('progress-percent').textContent = `${job.progress}%`;
            document.getElementById('progress-message').textContent = job.message;

            if (job.duration) {
                document.getElementById('detail-duration').textContent = `${(job.duration / 60).toFixed(1)} min`;
            }
        }

        function formatElapsed(seconds) {
            if (seconds < 60) return `${seconds}s`;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}m ${secs}s`;
        }

        async function transcribeWithOpenAI() {
            let apiKey = localStorage.getItem('openai_api_key');
            if (!apiKey) {
                apiKey = prompt('Enter your OpenAI API key:');
                if (!apiKey) {
                    document.getElementById('transcribe-btn').disabled = false;
                    return;
                }
                localStorage.setItem('openai_api_key', apiKey);
            }

            const statusPanel = document.getElementById('status-panel');
            statusPanel.classList.add('visible');
            document.getElementById('status-filename').textContent = currentFile.name;
            updateStatusPanel({ status: 'transcribing', progress: 30, message: 'Uploading to OpenAI...' });

            try {
                const formData = new FormData();
                formData.append('file', currentFile);
                formData.append('model', 'whisper-1');
                formData.append('response_format', 'verbose_json');

                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}` },
                    body: formData
                });

                updateStatusPanel({ status: 'transcribing', progress: 80, message: 'Processing...' });

                if (!response.ok) {
                    const error = await response.json();
                    if (error.error?.code === 'invalid_api_key') localStorage.removeItem('openai_api_key');
                    throw new Error(error.error?.message || 'API error');
                }

                const data = await response.json();
                const result = {
                    transcript: data.text,
                    word_count: data.text.split(/\s+/).length,
                    duration_seconds: currentFile.duration,
                    method: 'openai',
                    model: 'whisper-1',
                    cost_usd: (currentFile.duration / 60) * 0.006,
                    filename: currentFile.name
                };

                processedFiles.add(currentFile.name);
                showResult(result);
                saveToSupabase(result);
                sendNotification('Transcription Complete', `${result.word_count} words transcribed`);

            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
                statusPanel.classList.remove('visible');
                document.getElementById('transcribe-btn').disabled = false;
            }
        }

        function showResult(result) {
            document.getElementById('status-panel').classList.remove('visible');
            document.getElementById('result-panel').classList.add('visible');
            document.getElementById('transcript-box').textContent = result.transcript;
            document.getElementById('result-words').textContent = `${result.word_count} words`;
            document.getElementById('result-time').textContent = result.transcription_time_seconds
                ? `Transcribed in ${result.transcription_time_seconds.toFixed(1)}s` : '';
            document.getElementById('result-method').textContent = `via ${result.method === 'mlx_whisper' || result.method === 'mlx' ? 'MLX Whisper' : 'OpenAI'}`;
            if (result.cost_usd > 0) {
                document.getElementById('result-method').textContent += ` ($${result.cost_usd.toFixed(2)})`;
            }
            window.currentResult = result;
        }

        async function saveToSupabase(result) {
            try {
                const { data: memo, error: memoError } = await supabaseClient
                    .from('voice_memos')
                    .insert({
                        filename: result.filename,
                        file_hash: crypto.randomUUID(),
                        duration_seconds: result.duration_seconds,
                        status: 'completed'
                    })
                    .select()
                    .single();

                if (memoError) throw memoError;

                await supabaseClient.from('voice_transcripts').insert({
                    memo_id: memo.id,
                    transcript_text: result.transcript,
                    word_count: result.word_count,
                    model_used: result.model,
                    transcription_method: result.method
                });

                loadHistory();
            } catch (e) {
                console.error('Failed to save:', e);
            }
        }

        function copyTranscript() {
            if (window.currentResult) {
                navigator.clipboard.writeText(window.currentResult.transcript);
                showToast('Copied!', 'success');
            }
        }

        function downloadTranscript() {
            if (window.currentResult) {
                const blob = new Blob([window.currentResult.transcript], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = window.currentResult.filename.replace(/\.[^/.]+$/, '.txt');
                a.click();
            }
        }

        function resetUI() {
            currentFile = null;
            window.currentResult = null;
            document.getElementById('drop-zone').classList.remove('has-file');
            document.getElementById('file-info').style.display = 'none';
            document.getElementById('result-panel').classList.remove('visible');
            document.getElementById('status-panel').classList.remove('visible');
            document.getElementById('file-input').value = '';
            document.getElementById('duplicate-warning').style.display = 'none';
            updateTranscribeButton();
        }

        async function loadHistory() {
            try {
                const { data } = await supabaseClient
                    .from('voice_memos')
                    .select('*, voice_transcripts(*)')
                    .order('created_at', { ascending: false })
                    .limit(5);

                if (data?.length) {
                    data.forEach(m => processedFiles.add(m.filename));
                    document.getElementById('history-section').style.display = 'block';
                    document.getElementById('history-list').innerHTML = data.map(memo => {
                        const t = memo.voice_transcripts?.[0];
                        return `
                            <div class="history-item">
                                <div class="info">
                                    <div class="filename">${memo.filename}</div>
                                    <div class="meta">${memo.duration_seconds ? (memo.duration_seconds/60).toFixed(1) + ' min | ' : ''}${t?.word_count || 0} words</div>
                                </div>
                                ${t ? `<button class="btn btn-secondary" onclick="viewHistory('${memo.id}')">View</button>` : ''}
                            </div>
                        `;
                    }).join('');
                }
            } catch (e) { console.error(e); }
        }

        async function viewHistory(id) {
            const { data } = await supabaseClient
                .from('voice_memos')
                .select('*, voice_transcripts(*)')
                .eq('id', id)
                .single();

            if (data?.voice_transcripts?.[0]) {
                const t = data.voice_transcripts[0];
                window.currentResult = {
                    transcript: t.transcript_text,
                    word_count: t.word_count,
                    filename: data.filename,
                    method: t.transcription_method
                };
                showResult(window.currentResult);
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            document.getElementById('toast-container').appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
    </script>
</body>
</html>
