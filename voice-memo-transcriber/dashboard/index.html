<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Memo Transcriber</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1f1f1f;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #2a2a2a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 1.75rem;
            font-weight: 600;
        }

        .server-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error);
        }

        .status-dot.connected {
            background: var(--success);
        }

        /* Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 3rem 2rem;
            text-align: center;
            margin-bottom: 2rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.05);
        }

        .drop-zone.has-file {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.05);
        }

        .drop-zone h2 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        .drop-zone p {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .drop-zone input {
            display: none;
        }

        .file-info {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            text-align: left;
        }

        .file-info .filename {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .file-info .meta {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        /* Options Panel */
        .options-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .options-panel h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .option-group label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .option-group select,
        .option-group input[type="range"] {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .option-group input[type="range"] {
            padding: 0;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
        }

        .option-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .speed-value {
            font-size: 0.875rem;
            color: var(--accent);
            font-weight: 600;
        }

        /* Transcription Options */
        .transcribe-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .transcribe-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .transcribe-card:hover {
            border-color: var(--accent);
        }

        .transcribe-card.selected {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }

        .transcribe-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .transcribe-card h4 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .transcribe-card .badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            background: var(--success);
            color: white;
        }

        .transcribe-card .badge.paid {
            background: var(--warning);
        }

        .transcribe-card p {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .estimate {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .estimate .time {
            color: var(--text-primary);
        }

        .estimate .cost {
            color: var(--success);
            font-weight: 600;
        }

        .estimate .cost.paid {
            color: var(--warning);
        }

        /* Model Select for MLX */
        .model-select-wrapper {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .model-select-wrapper label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .model-select-wrapper select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        /* Transcribe Button */
        .transcribe-btn {
            width: 100%;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 2rem;
        }

        .transcribe-btn:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .transcribe-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Progress */
        .progress-container {
            display: none;
            margin-bottom: 2rem;
        }

        .progress-container.visible {
            display: block;
        }

        .progress-bar {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s;
            width: 0%;
        }

        .progress-text {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Result Panel */
        .result-panel {
            display: none;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .result-panel.visible {
            display: block;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .result-header h3 {
            font-size: 1.1rem;
        }

        .result-actions {
            display: flex;
            gap: 0.5rem;
        }

        .result-meta {
            display: flex;
            gap: 1.5rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .transcript-box {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1.5rem;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.9rem;
            line-height: 1.8;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 1000;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            margin-top: 0.5rem;
            animation: slideIn 0.3s ease;
        }

        .toast-success { border-color: var(--success); }
        .toast-error { border-color: var(--error); }
        .toast-warning { border-color: var(--warning); }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Server Required Notice */
        .server-notice {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid var(--warning);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.875rem;
        }

        .server-notice code {
            background: var(--bg-tertiary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: monospace;
        }

        /* History */
        .history-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
        }

        .history-section h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        .history-item {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item .info {
            flex: 1;
        }

        .history-item .filename {
            font-weight: 500;
        }

        .history-item .meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .transcribe-options { grid-template-columns: 1fr; }
            .options-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Voice Memo Transcriber</h1>
            <div class="server-status">
                <span class="status-dot" id="status-dot"></span>
                <span id="status-text">Checking server...</span>
            </div>
        </header>

        <div class="server-notice" id="server-notice" style="display: none;">
            <strong>Local server not running.</strong> Start it with:
            <code>cd voice-memo-transcriber && python server.py</code>
            <br><small>You can still use OpenAI (cloud) without the local server.</small>
        </div>

        <!-- Drop Zone -->
        <div class="drop-zone" id="drop-zone">
            <h2>Drop audio file here</h2>
            <p>or click to browse (mp3, m4a, wav, etc.)</p>
            <input type="file" id="file-input" accept="audio/*">
            <div class="file-info" id="file-info" style="display: none;">
                <div class="filename" id="filename"></div>
                <div class="meta" id="file-meta"></div>
            </div>
        </div>

        <!-- Preprocessing Options -->
        <div class="options-panel">
            <h3>Preprocessing Options</h3>
            <div class="options-grid">
                <div class="option-group">
                    <label>Playback Speed</label>
                    <input type="range" id="speed-slider" min="1" max="2" step="0.25" value="1">
                    <span class="speed-value" id="speed-value">1.0x (normal)</span>
                </div>
                <div class="option-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="remove-silence" checked>
                        <label for="remove-silence">Remove silence (faster)</label>
                    </div>
                </div>
                <div class="option-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="compress" checked>
                        <label for="compress">Compress audio (16kHz mono)</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Transcription Options -->
        <div class="transcribe-options">
            <div class="transcribe-card selected" id="card-local" onclick="selectMethod('local')">
                <h4>
                    Local (MLX Whisper)
                    <span class="badge">Free</span>
                </h4>
                <p>Runs on your Mac using Apple Silicon. Private - audio never leaves your device.</p>
                <div class="estimate">
                    <span class="time" id="local-time">~2 min</span>
                    <span class="cost">$0.00</span>
                </div>
                <div class="model-select-wrapper">
                    <label>Model</label>
                    <select id="mlx-model">
                        <option value="large-v3" selected>Large V3 (Best quality)</option>
                        <option value="large-v3-turbo">Large V3 Turbo (Faster)</option>
                        <option value="medium">Medium (Balanced)</option>
                        <option value="small">Small (Quick)</option>
                    </select>
                </div>
            </div>

            <div class="transcribe-card" id="card-openai" onclick="selectMethod('openai')">
                <h4>
                    OpenAI (Cloud)
                    <span class="badge paid">Paid</span>
                </h4>
                <p>Uses OpenAI's Whisper API. Fast, but requires API key and costs money.</p>
                <div class="estimate">
                    <span class="time" id="openai-time">~30 sec</span>
                    <span class="cost paid" id="openai-cost">$0.12</span>
                </div>
            </div>
        </div>

        <!-- Transcribe Button -->
        <button class="transcribe-btn" id="transcribe-btn" disabled>
            Select an audio file to transcribe
        </button>

        <!-- Progress -->
        <div class="progress-container" id="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Preparing...</div>
        </div>

        <!-- Result -->
        <div class="result-panel" id="result-panel">
            <div class="result-header">
                <h3>Transcript</h3>
                <div class="result-actions">
                    <button class="btn btn-primary" onclick="copyTranscript()">Copy</button>
                    <button class="btn btn-secondary" onclick="downloadTranscript()">Download</button>
                    <button class="btn btn-secondary" onclick="resetUI()">New File</button>
                </div>
            </div>
            <div class="result-meta">
                <span id="result-words">0 words</span>
                <span id="result-time">Transcribed in 0s</span>
                <span id="result-method">via Local</span>
            </div>
            <div class="transcript-box" id="transcript-box"></div>
        </div>

        <!-- History -->
        <div class="history-section" id="history-section" style="display: none;">
            <h3>Recent Transcripts</h3>
            <div id="history-list"></div>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script>
        // Configuration
        const LOCAL_SERVER = 'http://localhost:5111';
        const SUPABASE_URL = 'https://ydwjzlikslebokuxzwco.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inlkd2p6bGlrc2xlYm9rdXh6d2NvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg4NTEwODAsImV4cCI6MjA4NDQyNzA4MH0.CUPTmjww31xOS0-qknpQHByC3ACZ4lk1CiBcVZXHThU';

        // State
        let supabaseClient = null;
        let currentFile = null;
        let currentMethod = 'local';
        let serverAvailable = false;
        let estimates = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            setupEventListeners();
            checkServerStatus();
            loadHistory();
        });

        function setupEventListeners() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(event => {
                dropZone.addEventListener(event, e => { e.preventDefault(); e.stopPropagation(); });
                document.body.addEventListener(event, e => { e.preventDefault(); e.stopPropagation(); });
            });

            // Highlight drop zone
            ['dragenter', 'dragover'].forEach(event => {
                dropZone.addEventListener(event, () => dropZone.classList.add('drag-over'));
            });
            ['dragleave', 'drop'].forEach(event => {
                dropZone.addEventListener(event, () => dropZone.classList.remove('drag-over'));
            });

            // Handle drop
            dropZone.addEventListener('drop', e => handleFile(e.dataTransfer.files[0]));
            dropZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

            // Speed slider
            const speedSlider = document.getElementById('speed-slider');
            speedSlider.addEventListener('input', () => {
                const speed = parseFloat(speedSlider.value);
                const labels = { 1: '1.0x (normal)', 1.25: '1.25x', 1.5: '1.5x', 1.75: '1.75x', 2: '2.0x (fast)' };
                document.getElementById('speed-value').textContent = labels[speed] || `${speed}x`;
                updateEstimates();
            });

            // Preprocessing checkboxes
            document.getElementById('remove-silence').addEventListener('change', updateEstimates);
            document.getElementById('compress').addEventListener('change', updateEstimates);

            // Model select
            document.getElementById('mlx-model').addEventListener('change', updateEstimates);

            // Transcribe button
            document.getElementById('transcribe-btn').addEventListener('click', startTranscription);
        }

        async function checkServerStatus() {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const serverNotice = document.getElementById('server-notice');

            try {
                const response = await fetch(`${LOCAL_SERVER}/health`, { method: 'GET' });
                if (response.ok) {
                    const data = await response.json();
                    serverAvailable = true;
                    statusDot.classList.add('connected');
                    statusText.textContent = 'Server connected';
                    serverNotice.style.display = 'none';
                }
            } catch (e) {
                serverAvailable = false;
                statusDot.classList.remove('connected');
                statusText.textContent = 'Server offline';
                serverNotice.style.display = 'block';

                // If server not available, switch to OpenAI
                if (currentMethod === 'local') {
                    selectMethod('openai');
                }
                document.getElementById('card-local').classList.add('disabled');
            }
        }

        function selectMethod(method) {
            if (method === 'local' && !serverAvailable) {
                showToast('Local server not running. Start it first or use OpenAI.', 'warning');
                return;
            }

            currentMethod = method;
            document.querySelectorAll('.transcribe-card').forEach(card => card.classList.remove('selected'));
            document.getElementById(`card-${method === 'local' ? 'local' : 'openai'}`).classList.add('selected');
            updateTranscribeButton();
        }

        async function handleFile(file) {
            if (!file) return;

            // Check if audio file
            if (!file.type.startsWith('audio/') && !isAudioExtension(file.name)) {
                showToast('Please select an audio file', 'error');
                return;
            }

            currentFile = file;

            // Update UI
            const dropZone = document.getElementById('drop-zone');
            const fileInfo = document.getElementById('file-info');
            dropZone.classList.add('has-file');
            fileInfo.style.display = 'block';

            document.getElementById('filename').textContent = file.name;

            // Get duration
            const duration = await getAudioDuration(file);
            const durationMin = (duration / 60).toFixed(1);
            const sizeMB = (file.size / 1024 / 1024).toFixed(1);
            document.getElementById('file-meta').textContent = `${durationMin} min | ${sizeMB} MB`;

            // Store duration for estimates
            currentFile.duration = duration;

            updateEstimates();
            updateTranscribeButton();
        }

        function isAudioExtension(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            return ['mp3', 'm4a', 'wav', 'ogg', 'flac', 'aac', 'wma', 'opus', 'webm'].includes(ext);
        }

        function getAudioDuration(file) {
            return new Promise(resolve => {
                const audio = new Audio();
                audio.onloadedmetadata = () => resolve(audio.duration);
                audio.onerror = () => resolve(0);
                audio.src = URL.createObjectURL(file);
            });
        }

        function updateEstimates() {
            if (!currentFile || !currentFile.duration) return;

            const duration = currentFile.duration;
            const speed = parseFloat(document.getElementById('speed-slider').value);
            const removeSilence = document.getElementById('remove-silence').checked;
            const compress = document.getElementById('compress').checked;

            // Effective duration after preprocessing
            let effectiveDuration = duration / speed;
            if (removeSilence) effectiveDuration *= 0.8;

            // MLX estimates based on model
            const model = document.getElementById('mlx-model').value;
            const modelFactors = {
                'large-v3': 0.1,
                'large-v3-turbo': 0.07,
                'medium': 0.15,
                'small': 0.08
            };
            const mlxTime = effectiveDuration * (modelFactors[model] || 0.1);
            document.getElementById('local-time').textContent = formatTime(mlxTime);

            // OpenAI estimates
            const openaiTime = 30 + (effectiveDuration / 60) * 2;
            const openaiCost = (duration / 60) * 0.006;
            document.getElementById('openai-time').textContent = formatTime(openaiTime);
            document.getElementById('openai-cost').textContent = `$${openaiCost.toFixed(2)}`;

            estimates = { mlxTime, openaiTime, openaiCost };
        }

        function formatTime(seconds) {
            if (seconds < 60) return `~${Math.round(seconds)} sec`;
            return `~${(seconds / 60).toFixed(1)} min`;
        }

        function updateTranscribeButton() {
            const btn = document.getElementById('transcribe-btn');
            if (!currentFile) {
                btn.disabled = true;
                btn.textContent = 'Select an audio file to transcribe';
            } else if (currentMethod === 'local' && !serverAvailable) {
                btn.disabled = true;
                btn.textContent = 'Start local server to use MLX';
            } else {
                btn.disabled = false;
                const methodLabel = currentMethod === 'local' ? 'MLX Whisper' : 'OpenAI';
                btn.textContent = `Transcribe with ${methodLabel}`;
            }
        }

        async function startTranscription() {
            if (!currentFile) return;

            const btn = document.getElementById('transcribe-btn');
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');

            btn.disabled = true;
            progressContainer.classList.add('visible');
            progressFill.style.width = '0%';

            try {
                if (currentMethod === 'local') {
                    await transcribeLocal(progressFill, progressText);
                } else {
                    await transcribeOpenAI(progressFill, progressText);
                }
            } catch (error) {
                showToast(`Transcription failed: ${error.message}`, 'error');
                progressContainer.classList.remove('visible');
                btn.disabled = false;
            }
        }

        async function transcribeLocal(progressFill, progressText) {
            progressText.textContent = 'Uploading to local server...';
            progressFill.style.width = '10%';

            const formData = new FormData();
            formData.append('file', currentFile);
            formData.append('method', 'mlx');
            formData.append('model', document.getElementById('mlx-model').value);
            formData.append('speed', document.getElementById('speed-slider').value);
            formData.append('remove_silence', document.getElementById('remove-silence').checked);
            formData.append('compress', document.getElementById('compress').checked);

            progressText.textContent = 'Transcribing with MLX Whisper...';
            progressFill.style.width = '30%';

            // Simulate progress (actual progress would need WebSocket)
            const estimatedTime = estimates?.mlxTime || 60;
            const progressInterval = setInterval(() => {
                const current = parseFloat(progressFill.style.width);
                if (current < 90) {
                    progressFill.style.width = `${current + (60 / estimatedTime)}%`;
                }
            }, 1000);

            const response = await fetch(`${LOCAL_SERVER}/transcribe`, {
                method: 'POST',
                body: formData
            });

            clearInterval(progressInterval);

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Transcription failed');
            }

            const result = await response.json();
            progressFill.style.width = '100%';
            progressText.textContent = 'Complete!';

            await showResult(result);
            await saveToSupabase(result);
        }

        async function transcribeOpenAI(progressFill, progressText) {
            // Get API key from localStorage or prompt
            let apiKey = localStorage.getItem('openai_api_key');
            if (!apiKey) {
                apiKey = prompt('Enter your OpenAI API key:');
                if (!apiKey) throw new Error('API key required');
                localStorage.setItem('openai_api_key', apiKey);
            }

            progressText.textContent = 'Uploading to OpenAI...';
            progressFill.style.width = '20%';

            const formData = new FormData();
            formData.append('file', currentFile);
            formData.append('model', 'whisper-1');
            formData.append('response_format', 'verbose_json');

            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`
                },
                body: formData
            });

            progressFill.style.width = '80%';

            if (!response.ok) {
                const error = await response.json();
                if (error.error?.code === 'invalid_api_key') {
                    localStorage.removeItem('openai_api_key');
                }
                throw new Error(error.error?.message || 'OpenAI API error');
            }

            const data = await response.json();
            progressFill.style.width = '100%';
            progressText.textContent = 'Complete!';

            const result = {
                transcript: data.text,
                word_count: data.text.split(/\s+/).length,
                duration_seconds: currentFile.duration,
                method: 'openai',
                model: 'whisper-1',
                cost_usd: (currentFile.duration / 60) * 0.006,
                filename: currentFile.name
            };

            await showResult(result);
            await saveToSupabase(result);
        }

        async function showResult(result) {
            const resultPanel = document.getElementById('result-panel');
            const transcriptBox = document.getElementById('transcript-box');

            transcriptBox.textContent = result.transcript;
            document.getElementById('result-words').textContent = `${result.word_count} words`;
            document.getElementById('result-time').textContent = result.transcription_time_seconds
                ? `Transcribed in ${result.transcription_time_seconds.toFixed(1)}s`
                : '';
            document.getElementById('result-method').textContent = `via ${result.method === 'mlx' || result.method === 'local' ? 'MLX Whisper' : 'OpenAI'}`;

            if (result.cost_usd > 0) {
                document.getElementById('result-method').textContent += ` ($${result.cost_usd.toFixed(2)})`;
            }

            resultPanel.classList.add('visible');
            document.getElementById('progress-container').classList.remove('visible');

            // Store for copy/download
            window.currentResult = result;
        }

        async function saveToSupabase(result) {
            try {
                // Save memo
                const { data: memo, error: memoError } = await supabaseClient
                    .from('voice_memos')
                    .insert({
                        filename: result.filename,
                        file_hash: result.file_hash || crypto.randomUUID(),
                        duration_seconds: result.duration_seconds,
                        status: 'completed'
                    })
                    .select()
                    .single();

                if (memoError) throw memoError;

                // Save transcript
                const { error: transcriptError } = await supabaseClient
                    .from('voice_transcripts')
                    .insert({
                        memo_id: memo.id,
                        transcript_text: result.transcript,
                        word_count: result.word_count,
                        model_used: result.model,
                        transcription_method: result.method
                    });

                if (transcriptError) throw transcriptError;

                loadHistory();
            } catch (e) {
                console.error('Failed to save to Supabase:', e);
            }
        }

        function copyTranscript() {
            if (window.currentResult) {
                navigator.clipboard.writeText(window.currentResult.transcript);
                showToast('Copied to clipboard!', 'success');
            }
        }

        function downloadTranscript() {
            if (window.currentResult) {
                const blob = new Blob([window.currentResult.transcript], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = window.currentResult.filename.replace(/\.[^/.]+$/, '.txt');
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        function resetUI() {
            currentFile = null;
            window.currentResult = null;

            document.getElementById('drop-zone').classList.remove('has-file');
            document.getElementById('file-info').style.display = 'none';
            document.getElementById('result-panel').classList.remove('visible');
            document.getElementById('progress-container').classList.remove('visible');
            document.getElementById('file-input').value = '';

            updateTranscribeButton();
        }

        async function loadHistory() {
            try {
                const { data, error } = await supabaseClient
                    .from('voice_memos')
                    .select('*, voice_transcripts(*)')
                    .order('created_at', { ascending: false })
                    .limit(5);

                if (error) throw error;

                const historySection = document.getElementById('history-section');
                const historyList = document.getElementById('history-list');

                if (data && data.length > 0) {
                    historySection.style.display = 'block';
                    historyList.innerHTML = data.map(memo => {
                        const hasTranscript = memo.voice_transcripts && memo.voice_transcripts.length > 0;
                        const wordCount = hasTranscript ? memo.voice_transcripts[0].word_count : 0;
                        const duration = memo.duration_seconds ? `${(memo.duration_seconds / 60).toFixed(1)} min` : '';

                        return `
                            <div class="history-item">
                                <div class="info">
                                    <div class="filename">${memo.filename}</div>
                                    <div class="meta">${duration} | ${wordCount} words | ${new Date(memo.created_at).toLocaleDateString()}</div>
                                </div>
                                ${hasTranscript ? `<button class="btn btn-secondary" onclick="viewHistoryTranscript('${memo.id}')">View</button>` : ''}
                            </div>
                        `;
                    }).join('');
                }
            } catch (e) {
                console.error('Failed to load history:', e);
            }
        }

        async function viewHistoryTranscript(memoId) {
            const { data, error } = await supabaseClient
                .from('voice_memos')
                .select('*, voice_transcripts(*)')
                .eq('id', memoId)
                .single();

            if (data && data.voice_transcripts && data.voice_transcripts.length > 0) {
                const transcript = data.voice_transcripts[0];
                window.currentResult = {
                    transcript: transcript.transcript_text,
                    word_count: transcript.word_count,
                    filename: data.filename,
                    method: transcript.transcription_method || 'unknown'
                };

                document.getElementById('transcript-box').textContent = transcript.transcript_text;
                document.getElementById('result-words').textContent = `${transcript.word_count} words`;
                document.getElementById('result-time').textContent = '';
                document.getElementById('result-method').textContent = `via ${transcript.transcription_method || 'unknown'}`;
                document.getElementById('result-panel').classList.add('visible');
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }
    </script>
</body>
</html>
